<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Passenger&#39;s house</title>
  
  <subtitle>个人小站</subtitle>
  <link href="http://passengerdong.github.io/atom.xml" rel="self"/>
  
  <link href="http://passengerdong.github.io/"/>
  <updated>2024-11-18T15:33:25.981Z</updated>
  <id>http://passengerdong.github.io/</id>
  
  <author>
    <name>Passenger</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt5.15.2-Opencv4.8.0开发环境搭建</title>
    <link href="http://passengerdong.github.io/2024/05/12/Qt5-15-2-Opencv4-8-0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://passengerdong.github.io/2024/05/12/Qt5-15-2-Opencv4-8-0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2024-05-12T07:32:10.000Z</published>
    <updated>2024-11-18T15:33:25.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Qt5-15-2-Opencv4-8-0开发环境搭建"><a href="#Qt5-15-2-Opencv4-8-0开发环境搭建" class="headerlink" title="Qt5.15.2-Opencv4.8.0开发环境搭建"></a>Qt5.15.2-Opencv4.8.0开发环境搭建</h1><h2 id="1-安装QT5-15-2"><a href="#1-安装QT5-15-2" class="headerlink" title="1. 安装QT5.15.2  "></a><strong>1. 安装QT5.15.2</strong>  </h2><ul><li>首先，进入<img src="https://download.qt.io/official_releases/online_installers/" alt="Qt下载器">下载对应版本的下载器。</li><li>进入qt-unified-windows-x64-4.6.0-online.exe所在目录，在文件夹空白处点击右键，选择在终端中打开。<br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/ed2a295ea19888d71181761936fcc42e.png'><img src="https://www.z4a.net/images/2023/07/18/ed2a295ea19888d71181761936fcc42e.png" alt="终端打开"></li><li>使用官方服务器下载及其慢，我们使用腾讯镜像。在终端中输入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.\qt-unified-windows-x64-4.6.0-online.exe --mirror https://mirrors.cloud.tencent.com/qt/<br></code></pre></td></tr></table></figure class='item-img' data-src='https://www.z4a.net/images/2023/07/18/2668bc0fb3c8c71320ab7a273818f311.png'><img src="https://www.z4a.net/images/2023/07/18/2668bc0fb3c8c71320ab7a273818f311.png" alt="镜像"></li><li>回车，选择安装文件夹，在选择组件的步骤，勾选Qt-Qt 5.15.2-MingGw 8.1.0 64-bit，其他保持默认，等待安装完成。<br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/02ab9aa7439170c82259be3110c139c3.png'><img src="https://www.z4a.net/images/2023/07/18/02ab9aa7439170c82259be3110c139c3.png" alt="Qt安装"><br><strong>2. 解压opencv-4.8.0_build压缩包</strong></li></ul><hr><ul><li>我们只需关注其中的install文件夹。<br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/fc8c9050f79f861ee8cfa4ea0524dd04.png'><img src="https://www.z4a.net/images/2023/07/18/fc8c9050f79f861ee8cfa4ea0524dd04.png" alt="解压"></li></ul><h2 id="3-添加环境变量"><a href="#3-添加环境变量" class="headerlink" title="3. 添加环境变量"></a><strong>3. 添加环境变量</strong></h2><p class='item-img' data-src='https://www.z4a.net/images/2023/07/18/61126fd4fceb69aea62e8936073e651e.png'><img src="https://www.z4a.net/images/2023/07/18/61126fd4fceb69aea62e8936073e651e.png" alt="环境变量1"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/287bd48793fd191654be98f6b737a635.png'><img src="https://www.z4a.net/images/2023/07/18/287bd48793fd191654be98f6b737a635.png" alt="环境变量2"></p><ul><li>将如下目录添加至环境变量，注意你的路径和我的路径是不同的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">C:\Qt\5.15.2\mingw81_64\bin<br>C:\Qt\Tools\mingw810_64\bin<br>C:\configure\opencv-4.8.0_build\install\x64\mingw\bin<br></code></pre></td></tr></table></figure class='item-img' data-src='https://www.z4a.net/images/2023/07/18/6f37459c4f8ac72ba3fcfa0d0706c81e.png'><img src="https://www.z4a.net/images/2023/07/18/6f37459c4f8ac72ba3fcfa0d0706c81e.png" alt="环境变量3"></li><li><strong>重启电脑使环境变量生效</strong></li></ul><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a><strong>4.测试</strong></h2><ul><li>打开Qt Creator，选择创建项目，如图选择。<br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/6887bab50c677083c0f5b3b6ed68d9b5.png'><img src="https://www.z4a.net/images/2023/07/18/6887bab50c677083c0f5b3b6ed68d9b5.png" alt="测试1"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/2bd385fb80444f78ed471db0baac4e99.png'><img src="https://www.z4a.net/images/2023/07/18/2bd385fb80444f78ed471db0baac4e99.png" alt="测试2"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/51cf54b73fe4438760e6b3d396d0d119.png'><img src="https://www.z4a.net/images/2023/07/18/51cf54b73fe4438760e6b3d396d0d119.png" alt="测试3"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/58f575d5688475fc63109564d877b632.png'><img src="https://www.z4a.net/images/2023/07/18/58f575d5688475fc63109564d877b632.png" alt="测试4"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/5b2ef6fc3545288d46a8fa46153f9187.png'><img src="https://www.z4a.net/images/2023/07/18/5b2ef6fc3545288d46a8fa46153f9187.png" alt="测试5"><br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/e2d63f7df31cb759d768aa20b11f4641.png'><img src="https://www.z4a.net/images/2023/07/18/e2d63f7df31cb759d768aa20b11f4641.png" alt="测试6"></li><li>在pro文件末尾添加下列路径，注意你的路径和我的路径是不同的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">INCLUDEPATH += C:\configure\opencv-4.8.0_build\install\include<br>INCLUDEPATH += C:\configure\opencv-4.8.0_build\install\include\opencv2<br>LIBS += -L C:\configure\opencv-4.8.0_build\install\x64\mingw\lib\libopencv_*.a<br></code></pre></td></tr></table></figure class='item-img' data-src='https://www.z4a.net/images/2023/07/18/imageb8ccf1b07f0c4e1c.png'><img src="https://www.z4a.net/images/2023/07/18/imageb8ccf1b07f0c4e1c.png" alt="替换1"></li><li>替换main.cpp文件内容为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/core/core.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    cv::Mat image = <span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;C:\\configure\\1.png&quot;</span>);<br>    <span class="hljs-built_in">namedWindow</span>(<span class="hljs-string">&quot;Display window&quot;</span>,WINDOW_AUTOSIZE);<br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Display window&quot;</span>,image);<br>    <span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure class='item-img' data-src='https://www.z4a.net/images/2023/07/18/afdad14e1ea27cc7e1d98f934512e4c8.png'><img src="https://www.z4a.net/images/2023/07/18/afdad14e1ea27cc7e1d98f934512e4c8.png" alt="替换2"></li><li>点击左下角的三角形，运行,如果无报错，能显示图片说明一切正常，配置完毕。<br class='item-img' data-src='https://www.z4a.net/images/2023/07/18/a58dc9907c156c198cbbcd9d6b1a1e8c.png'><img src="https://www.z4a.net/images/2023/07/18/a58dc9907c156c198cbbcd9d6b1a1e8c.png" alt="结果"><br><em>如想自己编译opencv可参考此链接：<a href="https://blog.csdn.net/Mr_robot_strange/article/details/110677323,%22Qt-OpenCV%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E7%BB%86%EF%BC%89%22">Qt-OpenCV开发环境搭建（史上最详细）</a></em></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Qt5-15-2-Opencv4-8-0开发环境搭建&quot;&gt;&lt;a href=&quot;#Qt5-15-2-Opencv4-8-0开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Qt5.15.2-Opencv4.8.0开发环境搭建&quot;&gt;&lt;/a&gt;Qt5.15.2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STM32F4系列GPIO配置</title>
    <link href="http://passengerdong.github.io/2024/03/18/STM32F4%E7%B3%BB%E5%88%97GPIO%E9%85%8D%E7%BD%AE/"/>
    <id>http://passengerdong.github.io/2024/03/18/STM32F4%E7%B3%BB%E5%88%97GPIO%E9%85%8D%E7%BD%AE/</id>
    <published>2024-03-18T13:15:00.000Z</published>
    <updated>2024-11-18T15:34:04.364Z</updated>
    
    <content type="html"><![CDATA[<p>在stm32系列单片机的学习过程中，大部分人是从f1系列开始，今天第一次接触到f4系列的配置问题，所以写这篇博客进行简单的解释</p><p><strong>GPIO的基本结构见STM32学习笔记</strong>，f1系列和f4系列在结构上并无区别，只是在代码配置中有所区别</p><p>首先先看看在f1系列里面对GPIO的使能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="hljs-comment">//开启GPIOA的时钟</span><br><br><span class="hljs-comment">/*GPIO初始化*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="hljs-comment">//将PA2引脚初始化为复用推挽输出</span><br><span class="hljs-comment">//受外设控制的引脚，均需要配置为复用模式</span><br></code></pre></td></tr></table></figure><p>这里演示的是把PA2脚使能为推挽输出</p><p>我们可以将使能分为这么几步：</p><ol><li>打开时钟</li><li>初始化GPIO</li><li>Init函数完成初始化</li></ol><p>f4系列的初始化的大致步骤也是类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);<br><br>GPIO_InitTypeDef Serial_Structure;<br>Serial_Structure.GPIO_Mode = GPIO_Mode_AF;<br>Serial_Structure.GPIO_Pin = GPIO_Pin_9;<br>Serial_Structure.GPIO_Speed = GPIO_Speed_50MHz;<br>Serial_Structure.GPIO_OType = GPIO_OType_PP;<br>Serial_Structure.GPIO_PuPd = GPIO_PuPd_UP;<br>GPIO_Init(GPIOA, &amp;Serial_Structure);<br></code></pre></td></tr></table></figure><p>这里演示的是把PA9使能为推挽输出</p><p>可以注意到的是，两个GPIO使能的代码有细微的差别，比如：<br>f1中的时钟开启函数是：<code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</code>，而f4是：<code>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</code><br>f4的初始化结构体比f1多OType和PuPd需要配置</p><p>这些区别可以在各自的固件库文件中的stm32f4xx_gpio.c&#x2F;h和stm32f1xx_gpio.c&#x2F;h文件中找到</p><p>这边只给出f4系列配置的过程</p><p>在固件库每一个.c文件的开头都会有一段解释对应用法的说明</p><h1 id="f4-GPIO文件讲解"><a href="#f4-GPIO文件讲解" class="headerlink" title="f4 GPIO文件讲解"></a>f4 GPIO文件讲解</h1><p>stm32f4xx_gpio.c前面给出的说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  * @file    stm32f4xx_gpio.c</span><br><span class="hljs-comment">  * @author  MCD Application Team</span><br><span class="hljs-comment">  * @version V1.8.0</span><br><span class="hljs-comment">  * @date    04-November-2016</span><br><span class="hljs-comment">  * @brief   This file provides firmware functions to manage the following </span><br><span class="hljs-comment">  *          functionalities of the GPIO peripheral:           </span><br><span class="hljs-comment">  *           + Initialization and Configuration</span><br><span class="hljs-comment">  *           + GPIO Read and Write</span><br><span class="hljs-comment">  *           + GPIO Alternate functions configuration</span><br><span class="hljs-comment">  * </span><br><span class="hljs-comment">@verbatim  </span><br><span class="hljs-comment"> ===============================================================================</span><br><span class="hljs-comment">                      ##### How to use this driver #####</span><br><span class="hljs-comment"> ===============================================================================       </span><br><span class="hljs-comment"> [..]             </span><br><span class="hljs-comment">   (#) Enable the GPIO AHB clock using the following function</span><br><span class="hljs-comment">       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);</span><br><span class="hljs-comment">               </span><br><span class="hljs-comment">   (#) Configure the GPIO pin(s) using GPIO_Init()</span><br><span class="hljs-comment">       Four possible configuration are available for each pin:</span><br><span class="hljs-comment">       (++) Input: Floating, Pull-up, Pull-down.</span><br><span class="hljs-comment">       (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)</span><br><span class="hljs-comment">            Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed </span><br><span class="hljs-comment">            is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.</span><br><span class="hljs-comment">       (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open </span><br><span class="hljs-comment">            Drain (Pull-up, Pull-down or no Pull).</span><br><span class="hljs-comment">       (++) Analog: required mode when a pin is to be used as ADC channel or DAC </span><br><span class="hljs-comment">            output.</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   (#) Peripherals alternate function:</span><br><span class="hljs-comment">       (++) For ADC and DAC, configure the desired pin in analog mode using </span><br><span class="hljs-comment">            GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_AN;</span><br><span class="hljs-comment">            (+++) For other peripherals (TIM, USART...):</span><br><span class="hljs-comment">            (+++) Connect the pin to the desired peripherals&#x27; Alternate </span><br><span class="hljs-comment">                     Function (AF) using GPIO_PinAFConfig() function</span><br><span class="hljs-comment">            (+++) Configure the desired pin in alternate function mode using</span><br><span class="hljs-comment">                     GPIO_InitStruct-&gt;GPIO_Mode = GPIO_Mode_AF</span><br><span class="hljs-comment">            (+++) Select the type, pull-up/pull-down and output speed via </span><br><span class="hljs-comment">                     GPIO_PuPd, GPIO_OType and GPIO_Speed members</span><br><span class="hljs-comment">            (+++) Call GPIO_Init() function</span><br><span class="hljs-comment">          </span><br><span class="hljs-comment">   (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">   (#) To set/reset the level of a pin configured in output mode use </span><br><span class="hljs-comment">       GPIO_SetBits()/GPIO_ResetBits()</span><br><span class="hljs-comment">                 </span><br><span class="hljs-comment">   (#) During and just after reset, the alternate functions are not </span><br><span class="hljs-comment">       active and the GPIO pins are configured in input floating mode (except JTAG</span><br><span class="hljs-comment">       pins).</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">   (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose </span><br><span class="hljs-comment">       (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has </span><br><span class="hljs-comment">       priority over the GPIO function.</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">   (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as </span><br><span class="hljs-comment">       general purpose PH0 and PH1, respectively, when the HSE oscillator is off. </span><br><span class="hljs-comment">       The HSE has priority over the GPIO function.</span><br><span class="hljs-comment">               </span><br><span class="hljs-comment">@endverbatim        </span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  * @attention</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; COPYRIGHT 2016 STMicroelectronics&lt;/center&gt;&lt;/h2&gt;</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * Licensed under MCD-ST Liberty SW License Agreement V2, (the &quot;License&quot;);</span><br><span class="hljs-comment">  * You may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  * You may obtain a copy of the License at:</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  *        http://www.st.com/software_license_agreement_liberty_v2</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * Unless required by applicable law or agreed to in writing, software </span><br><span class="hljs-comment">  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, </span><br><span class="hljs-comment">  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">  * See the License for the specific language governing permissions and</span><br><span class="hljs-comment">  * limitations under the License.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  ******************************************************************************</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure><p>通过阅读这段说明我们可以知道如何使用这个文件里面的函数<br>当然这篇博客只涉及GPIO的初始化过程，所以我们只会讲解其中一部分，剩余可以自行去了解</p><p>从 ##### How to use this driver ##### 后面开始就是正式的讲解<br>这里我们只说明前面两段，这两段的内容足够我们完成GPIO的见到那配置</p><p>第一段：</p><p>Enable the GPIO AHB clock using the following function<br>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);</p><p>即使用<code>RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);</code>语句来进行时钟使能</p><p>第二段：</p><p>Configure the GPIO pin(s) using GPIO_Init()<br>Four possible configuration are available for each pin:<br>    (++) Input: Floating, Pull-up, Pull-down.<br>    (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)<br>        Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed<br>        is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.<br>    (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open<br>        Drain (Pull-up, Pull-down or no Pull).<br>    (++) Analog: required mode when a pin is to be used as ADC channel or DAC<br>        output.</p><p>这段讲解了结构体的配置，你需要确定的有：</p><ol><li>你使用的引脚</li><li>你选择的模式</li><li>你选择的传输速度</li></ol><p>文档里同时也说明了模式有哪些:</p><ol><li>输入 </li><li>输出</li><li>复用</li><li>模拟</li></ol><p>其中输入模式分为</p><ol><li>悬空</li><li>上拉</li><li>下拉</li></ol><p>输出分为：</p><ol><li>推挽</li><li>开漏</li></ol><p>复用需要同时设置输入和输出的两种</p><p>具体到代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE); <span class="hljs-comment">//开启时钟</span><br><br>GPIO_InitTypeDef Serial_Structure; <span class="hljs-comment">//初始化结构体</span><br>Serial_Structure.GPIO_Mode = GPIO_Mode_AF; <span class="hljs-comment">//选择模式</span><br>Serial_Structure.GPIO_Pin = GPIO_Pin_9; <span class="hljs-comment">//选择引脚</span><br>Serial_Structure.GPIO_Speed = GPIO_Speed_50MHz; <span class="hljs-comment">//选择速度</span><br>Serial_Structure.GPIO_OType = GPIO_OType_PP; <span class="hljs-comment">//选择输出模式</span><br>Serial_Structure.GPIO_PuPd = GPIO_PuPd_UP; <span class="hljs-comment">//选择输入模式</span><br>GPIO_Init(GPIOA, &amp;Serial_Structure); <span class="hljs-comment">//完成初始化</span><br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两个系列GPIO的初始化结构相同，只有细微区别，在使用前可以打开对应文件阅读说明，便于更好的理解和使用对应的函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在stm32系列单片机的学习过程中，大部分人是从f1系列开始，今天第一次接触到f4系列的配置问题，所以写这篇博客进行简单的解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GPIO的基本结构见STM32学习笔记&lt;/strong&gt;，f1系列和f4系列在结构上并无区别，只是在代码配置中有所区</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="嵌入式" scheme="http://passengerdong.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://passengerdong.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>stm32笔记2（不定更新 ）</title>
    <link href="http://passengerdong.github.io/2024/02/01/stm32%E7%AC%94%E8%AE%B02%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://passengerdong.github.io/2024/02/01/stm32%E7%AC%94%E8%AE%B02%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2024-02-01T11:13:43.000Z</published>
    <updated>2024-11-18T15:33:39.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32学习笔记"><a href="#STM32学习笔记" class="headerlink" title="STM32学习笔记"></a>STM32学习笔记</h1><p>这个笔记是基于HAL库的，跟随正中电子教程学习。</p><h2 id="单片机简介"><a href="#单片机简介" class="headerlink" title="单片机简介"></a>单片机简介</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>体积小，功耗低，集成度高，使用方便，拓展灵活</p><h2 id="Coetex-M"><a href="#Coetex-M" class="headerlink" title="Coetex-M"></a>Coetex-M</h2><h3 id="ARM公司"><a href="#ARM公司" class="headerlink" title="ARM公司"></a>ARM公司</h3><p>ARM只设计内核提供IP，不涉及芯片；</p><table><thead><tr><th align="center">对比项</th><th align="center">Cortex-A</th><th align="center">Cortex-B</th><th align="center">Cortex-C</th></tr></thead><tbody><tr><td align="center">特点</td><td align="center">高时钟频率，长流水线，高性能</td><td align="center">较高时钟频率，较长的流水线，实时性强</td><td align="center">时钟频率较低，通常较低的流水线，超低功耗</td></tr></tbody></table><h3 id="Cortex-M3-4-7-介绍"><a href="#Cortex-M3-4-7-介绍" class="headerlink" title="Cortex-M3&#x2F;4&#x2F;7 介绍"></a>Cortex-M3&#x2F;4&#x2F;7 介绍</h3><table><thead><tr><th align="center">类别</th><th align="center">Cortex-M3</th><th align="center">Cortex-M4</th><th align="center">Cortex-M7</th></tr></thead><tbody><tr><td align="center">核心版本</td><td align="center">ARMv7-M</td><td align="center">ARMv7E-M</td><td align="center">ARMv7E-M</td></tr><tr><td align="center">指令系统</td><td align="center">Thumb&#x2F;Thumb2</td><td align="center">Thumb&#x2F;Thumb2</td><td align="center">Thumb&#x2F;Thumb2</td></tr><tr><td align="center">DSP指令扩展</td><td align="center">无</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">浮点单元</td><td align="center">无</td><td align="center">单精度浮点单元</td><td align="center">可选单&#x2F;双精度浮点单元</td></tr><tr><td align="center">流水线</td><td align="center">3级</td><td align="center">3级+分支预测</td><td align="center">6级+分支预测</td></tr><tr><td align="center">中断</td><td align="center">NVIC，NMI+1~256个中断优先级</td><td align="center">NVIC，NMI+1~256个中断优先级</td><td align="center">NVIC，NMI+1~256个中断优先级</td></tr><tr><td align="center">系统定时器</td><td align="center">24位系统滴答定时器</td><td align="center">24位系统滴答定时器</td><td align="center">24位系统滴答定时器</td></tr><tr><td align="center">睡眠模式</td><td align="center">集成WFI和WFE指令及退出睡眠功能</td><td align="center">集成WFI和WFE指令及退出睡眠功能</td><td align="center">集成WFI和WFE指令及退出睡眠功能</td></tr><tr><td align="center">调试</td><td align="center">可选JTAG和SWD调试接口</td><td align="center">可选JTAG和SWD调试接口</td><td align="center">可选JTAG和SWD调试接口</td></tr><tr><td align="center">内存保护</td><td align="center">可选8个区域MPU</td><td align="center">可选8个区域MPU</td><td align="center">可选8&#x2F;16个区域MPU</td></tr><tr><td align="center">DPIMS&#x2F;Mhz</td><td align="center">1.25</td><td align="center">1.25</td><td align="center">2.14</td></tr><tr><td align="center">CoreMark®Mhz</td><td align="center">3.34</td><td align="center">3.43</td><td align="center">5.01</td></tr></tbody></table><h2 id="初识STM32"><a href="#初识STM32" class="headerlink" title="初识STM32"></a>初识STM32</h2><p>STM32 ST指意法半导体，M指MCU&#x2F;MPU，32指32位</p><h3 id="STM32命名规则"><a href="#STM32命名规则" class="headerlink" title="STM32命名规则"></a>STM32命名规则</h3><p>以STM32F051R8T6xxx为例：</p><p>STM32：家族（32位MCU&#x2F;MPU）</p><p>F：产品类型（基础型）</p><p>051：特定功能（3位数字）</p><p>R：引脚数（64&amp;66）</p><p>8：闪存容量（64Kbytes）</p><p>T:封装：（QFP）</p><p>6：温度范围（-40~+85）</p><p>x：固件版税</p><p>xx：选项</p><h3 id="STM引脚分布规则"><a href="#STM引脚分布规则" class="headerlink" title="STM引脚分布规则"></a>STM引脚分布规则</h3><p>小圆点放置左下角，圆点下第一个是1脚，逆时针依次为1.2.3……</p><p>芯片背面小三角对应的是小圆点的位置。</p><p>小圆点左侧从下向上依次是1-17，下侧左到右依次是A-Q，根据表可以找到对应内容</p><p>最小系统：保证MCU正常工作的最小电路组成单元</p><p>STM32复位引脚NRST保持低电平状态1~4.5ms即可复位（按键复位）</p><p>IO口微调：当IO不够用的时候，通用GPIO和特定外设·可能要公用IO口；为方便布线，可能要调整某些IO口的位置。</p><h4 id="STM32引脚类型"><a href="#STM32引脚类型" class="headerlink" title="STM32引脚类型"></a>STM32引脚类型</h4><ol><li>电源引脚（V开头）</li><li>晶振引脚（8、9，23、24）</li><li>复位引脚（25）</li><li>下载引脚<br>下载接口分为三类：<br> 1.JTAG（PA15、PA14、PA13、PB4、PB3、VDD、GND）<br> 2.SWD（PA14、PA13、VDD、GND）（占的少，可调式，推荐）<br> 3.串口（PA9、PA10、VDD、GND）（不可调试）<br>SWD：A13SWDIO输入&#x2F;输出；A14SWCLK时钟<br>JTAG：A13JTMS模式选择；A14JTCK时钟；A15JTDI输入；B3JTDO输出；B4TNTRST输入</li><li>BOOT引脚</li><li>GPIO引脚</li></ol><h2 id="软件及驱动"><a href="#软件及驱动" class="headerlink" title="软件及驱动"></a>软件及驱动</h2><h3 id="安装MDK和器件支持包"><a href="#安装MDK和器件支持包" class="headerlink" title="安装MDK和器件支持包"></a>安装MDK和器件支持包</h3><p>安装步骤：</p><ol><li>安装MDK</li><li>安装器件支持包</li><li>拷贝下载算法到Flash文件夹，如：C:\MDK5.34\ARM|Flash</li><li>购买授权并注册<del>我选择破解</del></li></ol><p><em>注：安装目录及路径不要汉字且越短越好，电脑系统名和用户名最好不要中文</em></p><h3 id="安装仿真器驱动"><a href="#安装仿真器驱动" class="headerlink" title="安装仿真器驱动"></a>安装仿真器驱动</h3><ul><li></li></ul><h3 id="安装CH340-USB虚拟串口驱动"><a href="#安装CH340-USB虚拟串口驱动" class="headerlink" title="安装CH340 USB虚拟串口驱动"></a>安装CH340 USB虚拟串口驱动</h3><p>打开exe直接点击安装即可，安装完成后，连接开发板，在设备管理器-&gt;端口可以找到对应设备</p><p>为什么要安装：可以使用通信协议</p><p>USB虚拟串口作用：</p><ol><li>当串口使用</li><li>如果连接串口1，还可以用来下载程序</li><li>当USB供电口</li></ol><h2 id="STM32初体验"><a href="#STM32初体验" class="headerlink" title="STM32初体验"></a>STM32初体验</h2><h3 id="使用MDK5编译历程"><a href="#使用MDK5编译历程" class="headerlink" title="使用MDK5编译历程"></a>使用MDK5编译历程</h3><p>部分编译和全局编译：时按两个效果相同，后续编译中，部分编译只编译当前文件</p><p>编译结果分析：</p><table><thead><tr><th align="center">数据类型</th><th align="center">占用Flash&#x2F;SRAM</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Code</td><td align="center">Flash</td><td align="center">代码</td></tr><tr><td align="center">RO-Data</td><td align="center">Flash</td><td align="center">只读数据，一般是指const修饰的数据</td></tr><tr><td align="center">RW-Data</td><td align="center">Flash&amp;SRAM</td><td align="center">初值为非0的可读可写数据</td></tr><tr><td align="center">ZI-Data</td><td align="center">SRAM</td><td align="center">初值为0的可读可写数据</td></tr></tbody></table><h3 id="串口下载程序"><a href="#串口下载程序" class="headerlink" title="串口下载程序"></a>串口下载程序</h3><h4 id="下载须知"><a href="#下载须知" class="headerlink" title="下载须知"></a>下载须知</h4><ol><li>M3、M4、M7支持串口下载程序但是ATK-XIPS.exe(正点研发的下载软件)只支持下载到内部Flash</li><li>STM32的ISP下载常用串口1下载程序</li><li>使用USB虚拟串口需事先下载驱动</li></ol><h4 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h4><p>PC(USB)-&gt;USB&#x2F;串口转换电路-&gt;TTL</p><h4 id="ATK-XISP-exe下载工具配置"><a href="#ATK-XISP-exe下载工具配置" class="headerlink" title="ATK-XISP.exe下载工具配置"></a>ATK-XISP.exe下载工具配置</h4><ol><li>搜索选择CH340虚拟的串口，然后设置波特率<br> <em>注：不同芯片内部的波特率可能不同，下载不了时可以调整波特率</em></li><li>选择需要下载的hex文件</li><li>勾选“编程后运行”、“校验”、“编程前执行全片擦除”</li><li>选择“DTR低电平复位，RTS高电平进BootLoader”</li><li>“开始编程”</li></ol><h4 id="STM32启动模式（M3和M4）"><a href="#STM32启动模式（M3和M4）" class="headerlink" title="STM32启动模式（M3和M4）"></a>STM32启动模式（M3和M4）</h4><p>通过BOOT0和BOOT1引脚设置启动模式（M3和M4）</p><p>BOOT1：X，BOOT0：0  ： 主闪存存储模式<br>BOOT1：0，BOOT0：1  ： 系统存储器<br>BOOT1：1，BOOT0：1  ： 内置SRAM</p><p><em>注：自举模式只支持引脚1（USART1）进行控制</em> </p><p>ISP下载步骤：<br>    1.BOOT0接高电平，BOOT1接低电平<br>    2.按复位键</p><p>程序执行一般步骤：<br>    1.BOOT0接低电平，BOOT1接任意<br>    2.按复位</p><p>（分别对应上面系统储存和主闪存存储模式）</p><p><strong>仿真调试依靠软件，这里暂不演示</strong></p><hr><h2 id="C语言知识点补充"><a href="#C语言知识点补充" class="headerlink" title="C语言知识点补充"></a>C语言知识点补充</h2><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><table><thead><tr><th align="center">运算符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center">^</td><td align="center">按位异或（相同取0相异取1）</td></tr><tr><td align="center">~</td><td align="center">按位取反</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td></tr></tbody></table><p>左移移除的部分不要，补充的部分写0；右移移除的部分不要，若为正数补充的部分补0，负数则补1</p><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>例：<br><code>#define LED1 0x01</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED(x) do&#123;x?\</span><br><span class="hljs-meta">    HAL_GPIO_WritePin(LED1_GPIO_PORT,LED_GPIO_PIN,GPIO_PIN_SET):\</span><br><span class="hljs-meta">    HAL_GPIO_WritePin(LED1_GPIO_PORT,LED_GPIO_PIN,GPIO_PIN_RESET):\</span><br><span class="hljs-meta">&#125;while(0)</span><br></code></pre></td></tr></table></figure><p>建议使用do{…}while(0)来构造宏定义，这样不会受大括号分号运算优先级等的影响</p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><table><thead><tr><th align="center">指令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">#if</td><td align="center">编译预处理条件指令，类似if</td></tr><tr><td align="center">#ifdef</td><td align="center">判断某个宏是否被定义</td></tr><tr><td align="center">#ifndef</td><td align="center">判断某个宏是否没有被定义</td></tr><tr><td align="center">#elif</td><td align="center">若前面条件不满足则判断新的条件，类似于else if</td></tr><tr><td align="center">#else</td><td align="center">若前面条件不满足则执行后面的语句，类似于else</td></tr><tr><td align="center">#endif</td><td align="center">#if,#ifdef,#ifndef的结束标志</td></tr></tbody></table><h3 id="extern声明"><a href="#extern声明" class="headerlink" title="extern声明"></a>extern声明</h3><p>放在函数&#x2F;变量前，可以在所有文件中找到并使用</p><h3 id="类型别名（typedef）"><a href="#类型别名（typedef）" class="headerlink" title="类型别名（typedef）"></a>类型别名（typedef）</h3><p>为现有的数据类型创建一个新的名字</p><p>结构为; <code>typedef 现有类型 新名字</code></p><p>e.p. <code>typedef unsigned char          uint8_t</code></p><p>类型别名应用（Struct）<br>正常情况下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GPIO_TypeDef</span></span><br><span class="hljs-class">&#123;</span><br>    __IO <span class="hljs-type">uint32_t</span> CRL;<br>    __IO <span class="hljs-type">uint32_t</span> CHR;<br>    …<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GPIO_TypeDef</span> <span class="hljs-title">gpiox</span></span><br></code></pre></td></tr></table></figure><p>使用typedef：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    __IO <span class="hljs-type">uint32_t</span> CRL;<br>    __IO <span class="hljs-type">uint32_t</span> CHR;<br>    …<br>&#125;GPIO_TypeDef;<br>GPIO_TypeDef gpiox<br></code></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>由若干基本数据类型集合组成的一种自定义数据类型，也叫聚合体</p><p>e.p.<br>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> group;<br>    <span class="hljs-type">float</span> score;<br>&#125;stu1,st2;<br></code></pre></td></tr></table></figure><p>应用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu3</span>,<span class="hljs-title">stu4</span>;</span><br>stu3.name=<span class="hljs-string">&quot;Trump&quot;</span>;<br>stu3.age=<span class="hljs-number">114</span>;<br></code></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针即内存的地址，指针变量就是保存了指针的变量</p><p>结构：<code>类型名 *指针变量名</code></p><p>e.p.:<code>char *p_str = &quot;Test&quot;;</code></p><p>*p_str：取p_str变量的值<br>&amp;p_str：取p_str变量的地址</p><p>指针使用的问题：</p><ol><li>未分配（申请）内存就使用</li><li>越界使用</li></ol><h2 id="STM基础知识"><a href="#STM基础知识" class="headerlink" title="STM基础知识"></a>STM基础知识</h2><h3 id="STM32系统框架"><a href="#STM32系统框架" class="headerlink" title="STM32系统框架"></a>STM32系统框架</h3><h3 id="F1系统框架"><a href="#F1系统框架" class="headerlink" title="F1系统框架"></a>F1系统框架</h3><p>4个主动单元+4个被动单元</p><table><thead><tr><th align="center">主动单元</th><th align="center">被动单元</th></tr></thead><tbody><tr><td align="center">Cortex M3内核 DCode总线(D-Bus)</td><td align="center">内部FLASH</td></tr><tr><td align="center">Cortex M3内核 系统总线 (S-Bus)</td><td align="center">内部SRAM</td></tr><tr><td align="center">通用DMA1</td><td align="center">FSMC</td></tr><tr><td align="center">通用DMA2</td><td align="center">AHB到APB的桥，他链接所有APB外设</td></tr></tbody></table><p><em>AHB：高级高性能总线</em><br><em>APB：高级外围总线</em></p><p>再互联型产品中有3个被动5个主动</p><h3 id="STM32选址范围"><a href="#STM32选址范围" class="headerlink" title="STM32选址范围"></a>STM32选址范围</h3><p>STM32寻址大小：2^32&#x3D;4G（字节）<br>STM32寻址范围：0x0000 0000~0xFFFF FFFF</p><h3 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h3><p>存储器是可以存储数据的设备，本身无地址信息，对存储器分配地址的过程称为存储器映射</p><h3 id="存储器功能划分（F1为例）"><a href="#存储器功能划分（F1为例）" class="headerlink" title="存储器功能划分（F1为例）"></a>存储器功能划分（F1为例）</h3><p>ST将4GB（2^32）地址空间分成8块</p><table><thead><tr><th align="center">存储块</th><th align="center">功能</th><th align="center">地址范围</th></tr></thead><tbody><tr><td align="center">Block0</td><td align="center">Code(FLASH)</td><td align="center">0x0000 0000 ~ 0x1FFF FFFF(512MB)</td></tr><tr><td align="center">Block1</td><td align="center">SRAM</td><td align="center">0x2000 0000 ~ 0x3FFF FFFF(512MB)</td></tr><tr><td align="center">Block2</td><td align="center">片上外设</td><td align="center">0x4000 0000 ~ 0x5FFF FFFF(512MB)</td></tr><tr><td align="center">Block3</td><td align="center">FSMC Blank1&amp;2</td><td align="center">0x6000 0000 ~ 0x7FFF FFFF(512MB)</td></tr><tr><td align="center">Block4</td><td align="center">FSMC Blanc3&amp;4</td><td align="center">0x8000 0000 ~ 0x9FFF FFFF(512MB)</td></tr><tr><td align="center">Block5</td><td align="center">FSMC寄存器</td><td align="center">0xA000 0000 ~ 0xBFFF FFFF(512MB)</td></tr><tr><td align="center">Block6</td><td align="center">没用到</td><td align="center">0xC000 0000 ~ 0xDFFF FFFF(512MB)</td></tr><tr><td align="center">Block7</td><td align="center">Cortex M3内部外设</td><td align="center">0xE000 0000 ~ 0xFFFF FFFF(512MB)</td></tr></tbody></table><h4 id="Block0（FLASH）功能划分："><a href="#Block0（FLASH）功能划分：" class="headerlink" title="Block0（FLASH）功能划分："></a>Block0（FLASH）功能划分：</h4><table><thead><tr><th align="center">功能</th><th align="center">地址范围</th></tr></thead><tbody><tr><td align="center">FLASH或系统存储器别名区</td><td align="center">0x0000 0000~0x0007 FFFF(512KB)</td></tr><tr><td align="center">保留</td><td align="center">0x0008 0000~0x07FF FFFF</td></tr><tr><td align="center">用户FLASH，用于存储用户代码</td><td align="center">0x0800 0000~0x0807 FFFF(521KB)</td></tr><tr><td align="center">保留</td><td align="center">0x0808 0000~0x1FFF EFFF</td></tr><tr><td align="center">系统存储器，存储出厂Bootloader</td><td align="center">0x1FFF F000~0x1FFF F7FF(2KB)</td></tr><tr><td align="center">选项字节，配置读保护等</td><td align="center">0x1FFF F800~0x1FFF F80F(16B)</td></tr><tr><td align="center">保留</td><td align="center">0x1FFF F810~0x1FFF FFFF</td></tr></tbody></table><h4 id="Block1-SRAM-功能划分"><a href="#Block1-SRAM-功能划分" class="headerlink" title="Block1(SRAM)功能划分"></a>Block1(SRAM)功能划分</h4><table><thead><tr><th align="center">功能</th><th align="center">地址范围</th></tr></thead><tbody><tr><td align="center">SRAM</td><td align="center">0x2000 0000~0x2000 FFFF(64KB)</td></tr><tr><td align="center">保留</td><td align="center">0x2001 0000~0x3FFF FFFF</td></tr></tbody></table><h4 id="Block2-外设-功能划分"><a href="#Block2-外设-功能划分" class="headerlink" title="Block2(外设)功能划分"></a>Block2(外设)功能划分</h4><table><thead><tr><th align="center">功能</th><th align="center">地址范围</th></tr></thead><tbody><tr><td align="center">APB1总线外设</td><td align="center">0x4000 0000~0x4000 77FF</td></tr><tr><td align="center">保留</td><td align="center">0x4000 7800~0x4000 FFFF</td></tr><tr><td align="center">APB2总线外设</td><td align="center">0x4001 0000~0x4000 3FFF</td></tr><tr><td align="center">保留</td><td align="center">0x4001 4000~0x4001 7FFF</td></tr><tr><td align="center">AHB总线外设</td><td align="center">0x4001 8000~0x4002 33FF</td></tr><tr><td align="center">保留</td><td align="center">0x4002 3400~0x5FFF FFFF</td></tr></tbody></table><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是单片机内部一种特殊的内存，可以实现对单片机各功能的控制</p><h4 id="STM32寄存器分类"><a href="#STM32寄存器分类" class="headerlink" title="STM32寄存器分类"></a>STM32寄存器分类</h4><p>内核寄存器：内核相关寄存器，中断寄存器，Sys Tick寄存器，内存保护寄存器，调试系统寄存器<br>外设寄存器：UART、IIC、SPI等</p><h4 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h4><p>给寄存器命名的过程叫做寄存器映射</p><p>例：0x4001080C–映射–&gt;GPIOA_ODR</p><p>直接映射：<br><code>*(unsigned int*)(0x4001 080C) = 0xFFFF;</code></p><p>定义名字之后映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOA_ODR   *(unsigned int*)(0x4001080C)</span><br>GPIOA_ODR = <span class="hljs-number">0xFFFF</span>;<br></code></pre></td></tr></table></figure><h4 id="寄存器描述解读"><a href="#寄存器描述解读" class="headerlink" title="寄存器描述解读"></a>寄存器描述解读</h4><p>要点：</p><ol><li>寄存器名字</li><li>偏移量及复位值</li><li>寄存器位表</li><li>位功能描述</li></ol><h4 id="寄存器地址计算"><a href="#寄存器地址计算" class="headerlink" title="寄存器地址计算"></a>寄存器地址计算</h4><p>为方便编写代码及使用，我们将寄存器地址分为三部分</p><ol><li>总线基地址(BUS_BASE_ADDR)</li><li>外设基于总线基地址的偏移量(PERIPH_OFFSET)</li><li>寄存器相对外设基地址的偏移量(REG_OFFSET)</li></ol><p><em>寄存器地址&#x3D;BUS_BASE_ADDR + PERIPH_OFFSET + REG_OFFSET</em></p><h5 id="总线基地址"><a href="#总线基地址" class="headerlink" title="总线基地址"></a>总线基地址</h5><table><thead><tr><th align="center">总线</th><th align="center">基地址</th><th align="center">偏移量</th></tr></thead><tbody><tr><td align="center">APB1</td><td align="center">0x4000 0000</td><td align="center">0</td></tr><tr><td align="center">APB2</td><td align="center">0x4001 0000</td><td align="center">0x1 0000</td></tr><tr><td align="center">AHB</td><td align="center">0x4001 8000</td><td align="center">0x1 8000</td></tr></tbody></table><p>APB1总线的基地址也叫做外设基地址(PERIPH_BASE)<br>此表的偏移量是相对外设基地址来说的</p><h5 id="GPIO基地址及偏移量"><a href="#GPIO基地址及偏移量" class="headerlink" title="GPIO基地址及偏移量"></a>GPIO基地址及偏移量</h5><table><thead><tr><th align="center">外设</th><th align="center">基地址</th><th align="center">偏移量</th></tr></thead><tbody><tr><td align="center">GPIOA</td><td align="center">0x4001 0800</td><td align="center">0x800</td></tr><tr><td align="center">GPIOB</td><td align="center">0x4001 0C00</td><td align="center">0xC00</td></tr><tr><td align="center">GPIOC</td><td align="center">0x4001 1000</td><td align="center">0x1000</td></tr><tr><td align="center">GPIOD</td><td align="center">0x4001 1400</td><td align="center">0x1400</td></tr><tr><td align="center">GPIOE</td><td align="center">0x4001 1800</td><td align="center">0x1800</td></tr><tr><td align="center">GPIOF</td><td align="center">0x4001 1C00</td><td align="center">0x1C00</td></tr><tr><td align="center">GPIOG</td><td align="center">0x4001 2000</td><td align="center">0x2000</td></tr></tbody></table><p>此表的偏移量是相对与APB2外设基地址(APB2PERIPH_BASE)来说的</p><h5 id="GPIOA外设基地址及偏移量"><a href="#GPIOA外设基地址及偏移量" class="headerlink" title="GPIOA外设基地址及偏移量"></a>GPIOA外设基地址及偏移量</h5><table><thead><tr><th align="center">寄存器</th><th align="center">地址</th><th align="center">偏移量</th></tr></thead><tbody><tr><td align="center">GPIOA_CRL</td><td align="center">0X4001 0800</td><td align="center">0X00</td></tr><tr><td align="center">GPIOA_CRH</td><td align="center">0X4001 0804</td><td align="center">0X04</td></tr><tr><td align="center">GPIOA_IDR</td><td align="center">0X4001 0808</td><td align="center">0X08</td></tr><tr><td align="center">GPIOA_ODR</td><td align="center">0X4001 080C</td><td align="center">0X0C</td></tr><tr><td align="center">GPIOA_BSRR</td><td align="center">0X4001 0810</td><td align="center">0X10</td></tr><tr><td align="center">GPIOA_BRR</td><td align="center">0X4001 0814</td><td align="center">0X14</td></tr><tr><td align="center">GPIOA_LCKR</td><td align="center">0X4001 0818</td><td align="center">0X18</td></tr></tbody></table><p>此表的偏移量是相对与GPIOA外设基地址(GPIO_BASE)来说的</p><p>寄存器地址计算举例（GPIOA_ODR）：</p><ol><li>获取外设挂载在那个总线（查系统结构图）</li><li>获取总线基地址，APB2总线基地址：0x4001 0000</li><li>获取外设偏移量，GPIOA相对APB2总线偏移量：0x800</li><li>获取寄存器地址偏移量，ORD相对GPIOA外设基地址偏移量是0x0C</li></ol><p>寄存器地址&#x3D;BUS_BASE_ADDR + PERIPH_OFFSET + REG_OFFSET<br>GPIOA_ODR&#x3D;0X4001 0000 +0X800 + 0X0C &#x3D; 0X4001 080C</p><p>利用结构体，我们可以很方便的完成对寄存器的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    __IO <span class="hljs-type">uint32_t</span> CRL;<br>    __IO <span class="hljs-type">uint32_t</span> CRH;<br>    __IO <span class="hljs-type">uint32_t</span> IDR;<br>    __IO <span class="hljs-type">uint32_t</span> ODR;<br>    __IO <span class="hljs-type">uint32_t</span> BSRR;<br>    __IO <span class="hljs-type">uint32_t</span> BRR;<br>    __IO <span class="hljs-type">uint32_t</span> LCKR;<br>&#125;GPIO_TypeDef;<br></code></pre></td></tr></table></figure><p><em>注：GPIOA_BASE: 0x4001 0800</em></p><p>由上面内容知道，GPIOA内每个寄存器偏移量都是0x04，uint_32大小刚好为0x04，能很好适配，利用这种方法可以方便的一次性配置一整个GPIO口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPIOA ((GPIO_TypeDef*)GPIOA_BASE)</span><br></code></pre></td></tr></table></figure><p>通过这个代码就可以一次性配置完整个GPIOA</p><p>此时：<br>&amp;GPIOA-&gt;CRL: 0x4001 0800<br>&amp;GPIOA_CRH: 0x4001 0804<br>……</p><p>配置完之后实际应用只需要<code>GPIOA-&gt;ODR = 0xFFFF</code>就完成对GPIOA下的ODR的写入</p><h3 id="新建寄存器MDK版本"><a href="#新建寄存器MDK版本" class="headerlink" title="新建寄存器MDK版本"></a>新建寄存器MDK版本</h3><h4 id="新建工程前的准备工作"><a href="#新建工程前的准备工作" class="headerlink" title="新建工程前的准备工作"></a>新建工程前的准备工作</h4><ol><li>下载相关STM32Cube官方固件包</li><li>搭建开发环境</li></ol><h4 id="新建寄存器版本MDK工程步骤"><a href="#新建寄存器版本MDK工程步骤" class="headerlink" title="新建寄存器版本MDK工程步骤"></a>新建寄存器版本MDK工程步骤</h4><ol><li>新建工程文件夹<br> D&#x2F;M&#x2F;O&#x2F;P&#x2F;U文件夹，5个文件夹</li><li>新建一个工程框架<br> 工程命名，选芯片</li><li>添加文件<br> 建分组，添加.s&#x2F;.c</li><li>魔术棒设置<br> T&#x2F;O&#x2F;L&#x2F;D&#x2F;C&#x2F;U，6个选项卡</li><li>添加mian.c并编写代码<br> 编写自己的代码</li></ol><table><thead><tr><th align="center">文件夹名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Drivers</td><td align="center">存放和硬件相关的驱动层文件</td></tr><tr><td align="center">Middlewares</td><td align="center">存放正点提供的中间层组件文件和第三方中间层文件</td></tr><tr><td align="center">Output</td><td align="center">存放工程编译输出文件</td></tr><tr><td align="center">Projects</td><td align="center">存放MDK文件</td></tr><tr><td align="center">Users</td><td align="center">存放HAL库用户配置文件、mian.c、中断文件，以及分散加载文件</td></tr></tbody></table><p>新建工程时要选择启动文件，其选择依据芯片类型，具体见下表</p><table><thead><tr><th align="center">缩写</th><th align="center">释义</th><th align="center">Flash容量</th><th align="center">型号</th></tr></thead><tbody><tr><td align="center">DL_VL</td><td align="center">小容量产品超值系列</td><td align="center">16-32K</td><td align="center">STM32F100</td></tr><tr><td align="center">MD_VL</td><td align="center">中容量产品超值系列</td><td align="center">64-128K</td><td align="center">STM32F100</td></tr><tr><td align="center">HD_VL</td><td align="center">大容量产品超值系列</td><td align="center">256-512K</td><td align="center">STM32F100</td></tr><tr><td align="center">LD</td><td align="center">小容量产品</td><td align="center">16-32K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">MD</td><td align="center">中容量产品</td><td align="center">64-128K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">HL</td><td align="center">大容量产品</td><td align="center">256-512K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">XL</td><td align="center">加大容量产品</td><td align="center">大于512K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">CL</td><td align="center">互联型产品</td><td align="center">-</td><td align="center">STM32F105&#x2F;107</td></tr></tbody></table><p>startup.stm32f103.s中有部分代码需要修改，按正点文件修改</p><p>魔术棒设置</p><ol><li>Target选项卡 设置使用的编译器版本、外部晶振频率</li><li>Output选项卡 设置Objects输出文件夹、生成.hex文件、输出浏览信息</li><li>Listing选项卡 设置Listing输出文件夹</li><li>C&#x2F;C++选项卡 设置全局宏定义、优化等级、C99 Mode、设置头文件包含路径</li><li>Debug选项卡 设置使用的仿真器类型、选择下载接口等</li><li>Utilities选项卡 设置下载功能、下载算法起始地址和算法等</li><li>Linker选项卡（可选） 添加分散加载文件（北极星&#x2F;MiniPro H750等）</li></ol><h2 id="认识HAL库"><a href="#认识HAL库" class="headerlink" title="认识HAL库"></a>认识HAL库</h2><p>ST提供了三种库：标准外设库、HAL库、LL库</p><p>直接操作寄存器：执行效率高、时间成本高<br>标准库：只兼容F0&#x2F;F1&#x2F;F3&#x2F;F4&#x2F;L1，目前停止维护<br>HAL库：全系列兼容、ST主推的库、兼容性、易移植性、效率低<br>LL库：全系列兼容，与HAL库捆绑发布，轻量级、效率高，不匹配复杂外设</p><h3 id="STM32固件包"><a href="#STM32固件包" class="headerlink" title="STM32固件包"></a>STM32固件包</h3><table><thead><tr><th align="center">Documentation</th><th align="center">Drivers</th><th align="center">Middleware</th><th align="center">Project</th><th align="center">Utilities</th><th align="center">Lisence.md</th><th align="center">package.xml</th><th align="center">Readme.md</th><th align="center">Release_Notes.html</th></tr></thead><tbody><tr><td align="center">说明文档</td><td align="center">驱动源码</td><td align="center">中间文件</td><td align="center">ST官方开发板案例教程</td><td align="center">公共组件</td><td align="center">软件版本信息</td><td align="center">固件包版本信息</td><td align="center">自述</td><td align="center">补充或更新说明</td></tr></tbody></table><h3 id="如何使用HAL库"><a href="#如何使用HAL库" class="headerlink" title="如何使用HAL库"></a>如何使用HAL库</h3><h4 id="基于CMSIS应用的程序文件描述"><a href="#基于CMSIS应用的程序文件描述" class="headerlink" title="基于CMSIS应用的程序文件描述"></a>基于CMSIS应用的程序文件描述</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d42a379f345e8d03451d2b.png'><img src="https://pic.imgdb.cn/item/65d42a379f345e8d03451d2b.png" alt="基于CMSIS应用的程序文件描述"></p><h4 id="STM32开发文件结构分布图"><a href="#STM32开发文件结构分布图" class="headerlink" title="STM32开发文件结构分布图"></a>STM32开发文件结构分布图</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d42bdd9f345e8d034a3584.png'><img src="https://pic.imgdb.cn/item/65d42bdd9f345e8d034a3584.png" alt="STM32开发文件结构分布"></p><h4 id="HAL库用户配置文件（stm32f1xx-hl-conf-h）"><a href="#HAL库用户配置文件（stm32f1xx-hl-conf-h）" class="headerlink" title="HAL库用户配置文件（stm32f1xx_hl_conf.h）"></a>HAL库用户配置文件（stm32f1xx_hl_conf.h）</h4><ol><li><p>裁剪HAL库外设驱动源码（不进行编译）</p><ol><li>仅包含使用到的文件</li><li>屏蔽不使用的宏的定义</li></ol></li><li><p>设置外部高速晶振频率（根据实际情况）</p></li><li><p>设置外部低速晶振频率（根据实际情况）</p></li></ol><h4 id="HAL库使用注意事项"><a href="#HAL库使用注意事项" class="headerlink" title="HAL库使用注意事项"></a>HAL库使用注意事项</h4><ol><li>使用HAL库出现问题还得通过参考实验手册检查是否有硬件操作问题</li><li>尽量不通过修改库源码实现功能，这样不方便库更新</li><li>HAL库可能会存在错误</li><li>有些HAL库API函数执行效率不高，我们可能会通过操作寄存器来直接替代</li></ol><h3 id="新建HAL库版本MDK工程"><a href="#新建HAL库版本MDK工程" class="headerlink" title="新建HAL库版本MDK工程"></a>新建HAL库版本MDK工程</h3><ol><li>新建工程前的准备工作</li><li>新建HAL库版本MDK工程步骤</li><li>下载验证</li></ol><h4 id="新建HAL库版本MDK工程步骤步骤"><a href="#新建HAL库版本MDK工程步骤步骤" class="headerlink" title="新建HAL库版本MDK工程步骤步骤"></a>新建HAL库版本MDK工程步骤步骤</h4><ol><li>新建工程文件夹<br> D&#x2F;M&#x2F;O&#x2F;P&#x2F;U文件夹，5个文件夹</li><li>新建一个工程框架<br> 工程命名，选芯片</li><li>添加文件<br> 建分组，添加.s&#x2F;.c</li><li>魔术棒设置<br> T&#x2F;O&#x2F;L&#x2F;D&#x2F;C&#x2F;U，6个选项卡</li><li>添加mian.c并编写代码<br> 编写自己的代码</li></ol><h5 id="新建工程文件夹"><a href="#新建工程文件夹" class="headerlink" title="新建工程文件夹"></a>新建工程文件夹</h5><table><thead><tr><th align="center">文件夹名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Drivers</td><td align="center">存放和硬件相关的驱动层文件</td></tr><tr><td align="center">Middlewares</td><td align="center">存放正点提供的中间层组件文件和第三方中间层文件</td></tr><tr><td align="center">Output</td><td align="center">存放工程编译输出文件</td></tr><tr><td align="center">Projects</td><td align="center">存放MDK文件</td></tr><tr><td align="center">Users</td><td align="center">存放HAL库用户配置文件、mian.c、中断文件，以及分散加载文件</td></tr></tbody></table><p>Drivers文件夹：</p><table><thead><tr><th align="center">文件夹名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">BSP</td><td align="center">存放开发板级支持包驱动代码，如各种外设驱动</td></tr><tr><td align="center">CMSIS</td><td align="center">存放CMSIS底层代码，如启动文件（.s文件）等</td></tr><tr><td align="center">SYSTEM</td><td align="center">存放正点原子系统级核心驱动代码，如sys.c、delay.c和usart.c等</td></tr><tr><td align="center">STM32F1xx_HAL_Drivers</td><td align="center">存放ST提供的F1系列HAL库驱动代码</td></tr></tbody></table><h5 id="新建一个工程框架"><a href="#新建一个工程框架" class="headerlink" title="新建一个工程框架"></a>新建一个工程框架</h5><ol><li>新建工程</li><li>保存工程</li><li>选择主控型号</li><li>删除文件夹</li></ol><table><thead><tr><th align="center">文件夹</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">DebugConfig</td><td align="center">用于存放调试设置的信息文件(.debconf)，不可删除</td></tr><tr><td align="center">Listings</td><td align="center">用于存放编译过程产生的链接列表等文件</td></tr><tr><td align="center">Objects</td><td align="center">用于存放编译过程产生的调试信息、.hex、预览、.lib文件等</td></tr></tbody></table><h5 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h5><ol><li>设置工程名和分组名</li><li>添加启动文件</li><li>添加User源码</li><li>添加SYSTEM源码</li><li>添加STM32F1xx_HAL_Driver源码</li></ol><h5 id="魔术棒设置"><a href="#魔术棒设置" class="headerlink" title="魔术棒设置"></a>魔术棒设置</h5><ol><li>Target选项卡 设置使用的编译器版本、外部晶振频率</li><li>Output选项卡 设置Objects输出文件夹、生成.hex文件、输出浏览信息</li><li>Listing选项卡 设置Listing输出文件夹</li><li>C&#x2F;C++选项卡 设置全局宏定义、优化等级、C99 Mode、设置头文件包含路径</li><li>Debug选项卡 设置使用的仿真器类型、选择下载接口等</li><li>Utilities选项卡 设置下载功能、下载算法起始地址和算法等</li><li>Linker选项卡（可选） 添加分散加载文件（北极星&#x2F;MiniPro H750等）</li></ol><h3 id="MAP文件浅析"><a href="#MAP文件浅析" class="headerlink" title="MAP文件浅析"></a>MAP文件浅析</h3><h4 id="MAP文件浅析-1"><a href="#MAP文件浅析-1" class="headerlink" title="MAP文件浅析"></a>MAP文件浅析</h4><table><thead><tr><th align="center">文件类型</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">.o</td><td align="center">可重定向对象文件，每个.c&#x2F;.s文件都对应一个.o文件</td></tr><tr><td align="center">.axf</td><td align="center">可执行对象文件，由.o文件连接成，仿真时需要用到此文件</td></tr><tr><td align="center">.hex</td><td align="center">INTEL Hex格式文件，用于下载到MCU运行，由.axf转换而来</td></tr><tr><td align="center">.map</td><td align="center">连接器生成的列表文件，对分析程序存储占用情况非常有用</td></tr><tr><td align="center">其他</td><td align="center">.ctf&#x2F;.d&#x2F;.dep&#x2F;.lnp&#x2F;.lst&#x2F;.build_log.thml等一般用不到的</td></tr></tbody></table><p>MAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息分析各.c文件占用FLASH 和 RAM的大小，方便优化代码</p><p>MAP文件组成：</p><table><thead><tr><th align="center">组成部分</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">程序段交叉引用关系</td><td align="center">描述各文件之间函数调用关系</td></tr><tr><td align="center">删除映像未使用的程序段</td><td align="center">描述工程中未使用到而被删除的冗余程序段</td></tr><tr><td align="center">映像符号表</td><td align="center">描述各符号（程序段&#x2F;数据）在存储器中的地址、类型、大小等</td></tr><tr><td align="center">映像内存分布图</td><td align="center">描述各个程序段（函数）在存储器中的地址及占用大小</td></tr><tr><td align="center">映像组件大小</td><td align="center">给出整个映像代码（.o）占用空间汇总信息</td></tr></tbody></table><h4 id="STM32启动模式"><a href="#STM32启动模式" class="headerlink" title="STM32启动模式"></a>STM32启动模式</h4><h5 id="STM32启动模式（也称自举模式）"><a href="#STM32启动模式（也称自举模式）" class="headerlink" title="STM32启动模式（也称自举模式）"></a>STM32启动模式（也称自举模式）</h5><p>M3&#x2F;M4&#x2F;M7等内核复位之后做的第一件事：</p><ol><li>从地址0x0000 0000处去除堆栈指针MSP的初始值，该值就是栈顶地址</li><li>从地址0x0000 0004处去除程序计数器指针PC的初始值，该值是复位向量</li></ol><h6 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h6><p>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65d49f569f345e8d03aa4459.png'><img src="https://pic.imgdb.cn/item/65d49f569f345e8d03aa4459.png" alt="F1"></p><p><em>无法下载程序解决方案：BOOT0接3.3V，按复位，然后在下载</em></p><h6 id="F4"><a href="#F4" class="headerlink" title="F4"></a>F4</h6><p>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65d49f569f345e8d03aa44de.png'><img src="https://pic.imgdb.cn/item/65d49f569f345e8d03aa44de.png" alt="F4"></p><p><em>如果要使用FSMC重映射到外部的SRAM，可以通过配置SYSCFG_MEMRMP寄存器</em><br><em>无法下载程序解决方案：BOOT0接3.3V，按复位，然后在下载</em></p><h6 id="F7"><a href="#F7" class="headerlink" title="F7"></a>F7</h6><p>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65d49f569f345e8d03aa460f.png'><img src="https://pic.imgdb.cn/item/65d49f569f345e8d03aa460f.png" alt="F7"></p><h6 id="H7"><a href="#H7" class="headerlink" title="H7"></a>H7</h6><p>在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65d4a5b09f345e8d03c434ed.png'><img src="https://pic.imgdb.cn/item/65d4a5b09f345e8d03c434ed.png" alt="H7"></p><h5 id="STM32启动过程（内部Flash启动为例）"><a href="#STM32启动过程（内部Flash启动为例）" class="headerlink" title="STM32启动过程（内部Flash启动为例）"></a>STM32启动过程（内部Flash启动为例）</h5><h6 id="启动文件介绍"><a href="#启动文件介绍" class="headerlink" title="启动文件介绍"></a>启动文件介绍</h6><ol><li>初始化MSP 从0x0800 0000获取</li><li>初始化PC 从0x0800 0004获取</li><li>设置堆栈大小 Heap_Size(堆)、Stack_Size(栈)</li><li>初始化中断向量表 __Vectors定义</li><li>调用初始化函数 可选，如调用：SysTeminitg函数</li><li>调用__main 标准C库函数，执行一系列设置，最后调用main函数</li></ol><h6 id="Reset-Handler函数介绍"><a href="#Reset-Handler函数介绍" class="headerlink" title="Reset_Handler函数介绍"></a>Reset_Handler函数介绍</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Reset_Handler   PROC<br>                EXPORT  Reset_Handler   [WEAK]<br>                IMPORT  __main<br>                IMPORT  SystemInit<br>                LDR   R0, =SystemInit<br>                BLX   R0               <br>                LDR   R0, =__main<br>                BX      R0<br>                ENDP<br></code></pre></td></tr></table></figure><p>EXPORT：标明全局属性，可被外部调用<br>IMPORT：申明来自外部文件，类extern<br>PROC：定义子程序<br>ENDP：表示子程序结束<br>WEAK：弱定义</p><h6 id="堆栈简介"><a href="#堆栈简介" class="headerlink" title="堆栈简介"></a>堆栈简介</h6><p>栈（Stack） ： 编译器自带分配和释放，存放函数参数、局部变量等<br>堆（Heap） ： 程序员分配和释放，如malloc、calloc、realloc等</p><h5 id="STM32启动过程图解"><a href="#STM32启动过程图解" class="headerlink" title="STM32启动过程图解"></a>STM32启动过程图解</h5><p class='item-img' data-src='https://www.z4a.net/images/2024/02/20/STM32.png'><img src="https://www.z4a.net/images/2024/02/20/STM32.png" alt="STM32启动过程图解"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32学习笔记&quot;&gt;&lt;a href=&quot;#STM32学习笔记&quot; class=&quot;headerlink&quot; title=&quot;STM32学习笔记&quot;&gt;&lt;/a&gt;STM32学习笔记&lt;/h1&gt;&lt;p&gt;这个笔记是基于HAL库的，跟随正中电子教程学习。&lt;/p&gt;
&lt;h2 id=&quot;单片机简介</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="嵌入式" scheme="http://passengerdong.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://passengerdong.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32学习笔记1（不定时更新）</title>
    <link href="http://passengerdong.github.io/2024/01/31/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://passengerdong.github.io/2024/01/31/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2024-01-31T02:41:30.000Z</published>
    <updated>2024-11-18T15:33:52.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32学习笔记"><a href="#STM32学习笔记" class="headerlink" title="STM32学习笔记"></a>STM32学习笔记</h1><p>这个笔记是基于标准库的，跟随江协教程学习。</p><h2 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1-新建工程"></a>1-新建工程</h2><p>新建工程时要选择启动文件，其选择依据芯片类型，具体见下表</p><table><thead><tr><th align="center">缩写</th><th align="center">释义</th><th align="center">Flash容量</th><th align="center">型号</th></tr></thead><tbody><tr><td align="center">DL_VL</td><td align="center">小容量产品超值系列</td><td align="center">16-32K</td><td align="center">STM32F100</td></tr><tr><td align="center">MD_VL</td><td align="center">中容量产品超值系列</td><td align="center">64-128K</td><td align="center">STM32F100</td></tr><tr><td align="center">HD_VL</td><td align="center">大容量产品超值系列</td><td align="center">256-512K</td><td align="center">STM32F100</td></tr><tr><td align="center">LD</td><td align="center">小容量产品</td><td align="center">16-32K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">MD</td><td align="center">中容量产品</td><td align="center">64-128K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">HL</td><td align="center">大容量产品</td><td align="center">256-512K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">XL</td><td align="center">加大容量产品</td><td align="center">大于512K</td><td align="center">STM32F101&#x2F;102&#x2F;103</td></tr><tr><td align="center">CL</td><td align="center">互联型产品</td><td align="center">-</td><td align="center">STM32F105&#x2F;107</td></tr></tbody></table><p>总结：<br>新建工程的步骤：<br>· 建立工程文件夹，Keil中新建工程，选择型号<br>· 工程文件夹里建立StartLibrary、User等文件夹，2复制固件库里面的文件到工程文件夹<br>· 工程里对应建立Start、Library、User等同名称的分组，然后将文件夹的文件添加到工程分组里<br>· 工程选项，C&#x2F;C++，Include Paths内声明所有包含头文件的文件夹<br>· 工程选项，C&#x2F;C++，Define内定义USE_STDPERIPH_DRIVER<br>· 工程选项，Debug，下拉列表选择对应调试器，Settings,FlashDownload里勾选Reset and Run</p><p>工程架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">startup_xx.c：                  system_xx.c/.h:         stm32f10x.h:<br>    复位中断：                     定义Systeminit           外设寄存器描述<br>        调用Systeminit          main.c:                 core_cm3.c/.h:<br>        调用main                    定义main                内核寄存器描述<br>    其他中断：                  stm32f10x_it.c/.h:      misc.c/.h,stm32f10x_abc.c/.h…：<br>        调用中断                    定义中断                库函数<br>        处理函数                    处理函数            stm32f10x_conf.h:<br>                                其他用户文件                库函数配置<br></code></pre></td></tr></table></figure><h2 id="2-GPIO"><a href="#2-GPIO" class="headerlink" title="2-GPIO"></a>2-GPIO</h2><h3 id="GPIO简介"><a href="#GPIO简介" class="headerlink" title="GPIO简介"></a>GPIO简介</h3><p>GPIO即通用输入输出口<br>可配置8种输入输出模式<br>引脚：0-3.3V，部分可容忍5V</p><p>输出模式下可以控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等<br>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p><h3 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba63a7871b83018aa7fdf4.png'><img src="https://pic.imgdb.cn/item/65ba63a7871b83018aa7fdf4.png" alt="GPIO结构框图"></p><p>由于stm32是32位的单片机，stm32内部的寄存器都是32位的，但是端口只有16个，所以寄存器<strong>只有低16位有对应端口</strong></p><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba63a6871b83018aa7fc1c.png'><img src="https://pic.imgdb.cn/item/65ba63a6871b83018aa7fc1c.png" alt="GPIO电路图"><br><em>注：输入驱动器中的肖特基触发器实际为施密特触发器，此处为翻译错误</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">施密特触发器：当电压高于一定值的时候立马输出高电压，当电压低于一定值的时候立马输出低电压，处于中间保持<br>此处用于整形，防止信号失真<br></code></pre></td></tr></table></figure><p>输出数据清除器<strong>同时控制16个端口</strong>且<strong>只能整体读写</strong>，想要控制个别位需要用”&amp;&#x3D;”以及”|&#x3D;”的方法，比较麻烦，利用前面的位设置&#x2F;清除寄存器可以仅控制输出数据寄存器的某一位而不影响其他位</p><p>输出控制有推挽、开漏、关闭三种输出模式</p><ol><li><p>推挽：此模式下，P-MOS和N-MOS<strong>均有效</strong>。数据寄存器为1时，P导通N断开，输出接VDD，高电平；数据寄存器为0时，P断开N导通，输出接VSS，低电平。此状态下高低电平均有较强驱动能力，所以又称<strong>强推输出模式</strong>。</p></li><li><p>开漏：此模式下<strong>P-MOS无效</strong>，N-MOS有效。数据寄存器为1时，N断开，相当于输出断开，也就是<strong>高阻模式</strong>；数据寄存器为0时，N导通，输出接VSS，低电平。此模式可以作为通信协议的驱动模式，如I2C，此模式下可以避免各个设备的相互干扰；同时在此模式下，通过在IO口外接上拉电源（以5V为例），数据寄存器输出1时由外部电路上拉到5V，就可以兼容5V的设备。</p></li><li><p>关闭，此时P-MOS和N-MOS均关闭，IO口由外部电路控制。</p></li></ol><h3 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h3><p>通过配置GPIO的端口寄存器，端口可配置成以下8种模式</p><p>四种输出方式：<br>　　（1）推挽输出   可输出引脚电平，高电平为高阻态，低电平接VSS<br>　　（2）开漏输出   可输出引脚电平，高电平接VDD，低电平接VSS<br>　　（3）复用推挽   由片上外设控制，高电平为高阻态，低电平接VSS<br>　　（4）复用开漏   由片上外设控制，高电平接VDD，低电平接VSS</p><p>四种输入方式：<br>　　（1）浮空输入   可读取引脚电平，若引脚悬空，则电平不确定<br>　　（2）上拉输入   可读取引脚电平，内部连接上拉电阻，悬空时默认高电平<br>　　（3）下拉输入   可读取引脚电平，内部连接下拉电阻，悬空时默认低电平<br>　　（4）模拟输入   GPIO无效，引脚直接接入内部ADC</p><h4 id="浮空-上拉-下拉输入"><a href="#浮空-上拉-下拉输入" class="headerlink" title="浮空&#x2F;上拉&#x2F;下拉输入"></a>浮空&#x2F;上拉&#x2F;下拉输入</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png'><img src="https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png" alt="浮空/上拉/下拉输入"></p><p>在输入模式下，输出寄存器是断开的，端口只能输入而不能输出。<br>输入寄存器的两个的电阻可以上拉工作下拉工作或者都不工作，对应上拉输入下拉输入和浮空输入。<br>右侧保护二极管，VDD和VDD_FT不同，后者对5V容忍IO脚是特殊的</p><h4 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png'><img src="https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png" alt="模拟输入"></p><p>在次模式下，IO口直接模拟输入，其余部分全部无效</p><h4 id="开漏-推挽输出"><a href="#开漏-推挽输出" class="headerlink" title="开漏&#x2F;推挽输出"></a>开漏&#x2F;推挽输出</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65baf0eb871b83018af5e26e.png'><img src="https://pic.imgdb.cn/item/65baf0eb871b83018af5e26e.png" alt="开漏/推挽输出模式"></p><p>P-MOS无效时是开漏输出，P-MOS和N-MOS均有效时是推挽输出。<br>在输出模式下输入模式是有效的。</p><h4 id="复用开漏-复用推挽输出"><a href="#复用开漏-复用推挽输出" class="headerlink" title="复用开漏&#x2F;复用推挽输出"></a>复用开漏&#x2F;复用推挽输出</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65baf6d1871b83018a053483.png'><img src="https://pic.imgdb.cn/item/65baf6d1871b83018a053483.png" alt="复用开漏/复用推挽输出"></p><p>此状态下通用输出没有连接，引脚的控制权转移到片上外设。</p><h4 id="LED和蜂鸣器"><a href="#LED和蜂鸣器" class="headerlink" title="LED和蜂鸣器"></a>LED和蜂鸣器</h4><p>LED：反光二极管</p><p>蜂鸣器：分为有源无源，有源自带振荡源，接上直流电压即可持续发声；无源内部不带振荡源，需要控制器提供震荡脉冲才可发声，调整振荡脉冲频率可发出不同频率的声音。</p><h4 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h4><p>结构如下图：<br class='item-img' data-src='https://www.z4a.net/images/2024/02/01/41429c4624ea25d0066ab0ef1b4f3292.png'><img src="https://www.z4a.net/images/2024/02/01/41429c4624ea25d0066ab0ef1b4f3292.png" alt="面包板"></p><h3 id="应用1-LED闪烁"><a href="#应用1-LED闪烁" class="headerlink" title="应用1.LED闪烁"></a>应用1.LED闪烁</h3><p>电路板连接图：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1afd871b83018a6de2f1.jpg'><img src="https://pic.imgdb.cn/item/65bb1afd871b83018a6de2f1.jpg" alt="3.1LED闪烁"></p><p>使用GPIO点灯的步骤：</p><ol><li>使用RCC开启GPIO时钟；</li><li>使用GPIO_Init()函数初始化</li><li>使用输出或者输入函数控制GPIO口</li></ol><p>GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)和GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)是设置引脚电平的两个函数，其中第一个参数是GPIO口（如GPIOA），第二个参数是引脚号（如GPIO_PIN_0）</p><p>攥写一段代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    GPIO_ResetBits(GPIOA,GPIO_Pin_0);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写入后得到现象如下图：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1f3e871b83018a7a4bbb.jpg'><img src="https://pic.imgdb.cn/item/65bb1f3e871b83018a7a4bbb.jpg" alt="GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)"></p><p>可以看到LED成功被点亮。</p><p>在我们使用GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)时，LED熄灭。</p><p>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)是对单个引脚写入信号的函数，在上程序中，将<code>GPIO_ResetBits(GPIOA,GPIO_Pin_0);</code>替换为<code>GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</code>也能得到点亮的效果。</p><p>下面我们要实现LED的闪烁，通过使用Delay模块即可实现（Delay模块的编写在之后的课程）。代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写入后，可以观察到LED闪烁。使用SetBits或者ResetBits得到的效果同样。</p><p><em>在WriteBit函数中，BIT_(RE)SET可以换成0或者1，但是前面要加上”(BitAction)”切换成枚举类型</em></p><p>将LED长短脚位置互换之后，LED依旧闪烁，说明推挽模式下高低电平都有驱动能力；将模式改成OUT_OD（开漏输出）LED不亮了，说明开漏输出的高电平无驱动能力，重新将LED长短脚换回原来位置，LED回复闪烁，说明开漏模式下低电平有驱动能力。</p><h3 id="应用2-LED流水灯"><a href="#应用2-LED流水灯" class="headerlink" title="应用2.LED流水灯"></a>应用2.LED流水灯</h3><p>面包板连线：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1afe871b83018a6de519.jpg'><img src="https://pic.imgdb.cn/item/65bb1afe871b83018a6de519.jpg" alt="LED流水灯"></p><p>在编写流水灯的程序，设置引脚的时候可以使用“|”来同时设置多个引脚，在流水灯应用中，我们需要使用0-7，共八个引脚，所以可以写<code>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;</code></p><p>最终代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            GPIO_Write(GPIOA,~(<span class="hljs-number">0x0001</span>&lt;&lt;i));<br>            Delay_ms(<span class="hljs-number">500</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb4d66871b83018a0d95af.jpg'><img src="https://pic.imgdb.cn/item/65bb4d66871b83018a0d95af.jpg" alt="LED 流水灯效果图"></p><h3 id="应用3-蜂鸣器"><a href="#应用3-蜂鸣器" class="headerlink" title="应用3.蜂鸣器"></a>应用3.蜂鸣器</h3><p>面包板连线：<br class='item-img' data-src='https://www.z4a.net/images/2024/02/01/3-3-.jpg'><img src="https://www.z4a.net/images/2024/02/01/3-3-.jpg" alt="蜂鸣器"></p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<br>    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        GPIO_ResetBits(GPIOB,GPIO_Pin_13);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>        GPIO_SetBits(GPIOB,GPIO_Pin_13);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：我在使用的时候连接了B13，所以代码中写的是13</em></p><h3 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h3><p>给予的工具包包含了四个传感器模块：光敏&#x2F;热敏&#x2F;对射式红外&#x2F;反射式红外传感器，图片及电路图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bd98c3871b83018ad50af4.png'><img src="https://pic.imgdb.cn/item/65bd98c3871b83018ad50af4.png" alt="传感器"><br class='item-img' data-src='https://pic.imgdb.cn/item/65bd98c2871b83018ad50a67.png'><img src="https://pic.imgdb.cn/item/65bd98c2871b83018ad50a67.png" alt="传感器电路图"></p><p>结构较简单，不多赘述</p><h3 id="部分C语言知识点"><a href="#部分C语言知识点" class="headerlink" title="部分C语言知识点"></a>部分C语言知识点</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><em>浮点数不能加unsigned</em></p><p>在单片机编程中，原本用于定义字符的char常被用于定义整形，所以C和ST就给其定义了新的关键字，出处于相同原因，部分其他关键字也被定义了新的名字，具体见下表：</p><table><thead><tr><th align="center">关键字</th><th align="center">位数</th><th align="center">表示范围</th><th align="center">stdint关键字</th><th align="center">ST关键字</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">8</td><td align="center">-128 - 127</td><td align="center">int8_t</td><td align="center">s8</td></tr><tr><td align="center">unsigned char</td><td align="center">8</td><td align="center">0-255</td><td align="center">uint8_t</td><td align="center">u8</td></tr><tr><td align="center">short</td><td align="center">16</td><td align="center">-32768 - 32767</td><td align="center">int16_t</td><td align="center">s16</td></tr><tr><td align="center">unsigned short</td><td align="center">16</td><td align="center">0 - 65535</td><td align="center">uint16_t</td><td align="center">u16</td></tr><tr><td align="center">int</td><td align="center">32</td><td align="center">-2147483648 - 2147483647</td><td align="center">int32_t</td><td align="center">s32</td></tr><tr><td align="center">unsigned int</td><td align="center">32</td><td align="center">0 - 4294967295</td><td align="center">uint32_t</td><td align="center">u32</td></tr><tr><td align="center">long</td><td align="center">32</td><td align="center">-2147483648 - 2147483647</td><td align="center"></td><td align="center">s32</td></tr><tr><td align="center">unsigned long</td><td align="center">32</td><td align="center">0 - 4294967295</td><td align="center"></td><td align="center">u32</td></tr><tr><td align="center">long long</td><td align="center">64</td><td align="center">-(2^64)&#x2F;2 - (2^64)&#x2F;2-1</td><td align="center">int64_t</td><td align="center"></td></tr><tr><td align="center">unsigned long long</td><td align="center">32</td><td align="center">0 - (2^64)-1</td><td align="center">uint64_t</td><td align="center"></td></tr><tr><td align="center">float</td><td align="center">32</td><td align="center">-3.4e38 - 3.4e38</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">64</td><td align="center">-1.7e308 &#x3D; 1.7e308</td><td align="center"></td><td align="center"></td></tr></tbody></table><p><em>注：ST关键字是老版本的，推荐使用stdint关键字</em></p><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>·关键字：#define<br>·用途：将一个字符串改成数字，便于理解防止出错；提取程序中常出现的参数，便于修改</p><p>e.p. : 定义宏定义：<br>        #define ABC 12345<br>       引用宏定义：<br>        int a &#x3D; ABC; &#x2F;&#x2F;等效于int a &#x3D; 12345;</p><h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>·关键字：typedef<br>·用途：将比较长的变量类型名字改名字，便于使用</p><p>e.p. : 定义typedef：<br>        typedef unsigned char uint8_t;<br>       引用typedef：<br>        unit8_t a; &#x2F;&#x2F;等效于unsigned char a;</p><p>与宏定义的不同：<br>    1. 新名字在后面<br>    2. 仅能用于变量类型名<br>    3. typedef会进行检查，更安全</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>·关键字：struct<br>·用途：数据打包，不同类型变量的集合</p><p>e.p. : 定义结构体：<br>        struct{char x;int y;float z;} StructName;<br>        <em>因为结构体变量类型较长，所以常用typedef更改变量类型名</em><br>       引用结构体：<br>        StructName.x&#x3D; ‘A’;<br>        StructName.y&#x3D; 66;<br>        StructName. z&#x3D; 1.14;<br>    或：pStructName-&gt;x&#x3D; ‘A’;    &#x2F;&#x2F;pSrtuctName是结构体的地址<br>        pStructName-&gt;y&#x3D; 66;<br>        pStructName-&gt;z&#x3D; 1.14;</p><p>使用typedef举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">float</span> z;<br>&#125; StructName_1;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    StructName_1 c;<br>    StructName_1 d;<br>    c.x= <span class="hljs-string">&#x27;A&#x27;</span>;<br>    c.y= <span class="hljs-number">66</span>;<br>    c. z= <span class="hljs-number">1.14</span>;<br><br>    prinf(<span class="hljs-string">&quot;c.x-%c\n&quot;</span>,c.x);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>·关键字：enum<br>·用途：定义一个取值受限的整型变量，用于限制变量取值范围；宏定义的集合</p><p>e.p. : 定义枚举变量：<br>        enum{FALSE &#x3D; 0, TRUE &#x3D; 1} EnumName;<br>        <em>因为枚举变量变量类型较长，所以常用typedef更改变量类型名</em><br>       引用typedef：<br>        EnumName&#x3D;FALSE;<br>        EnumName&#x3D;TRUE;</p><h3 id="应用4-按键控制LED"><a href="#应用4-按键控制LED" class="headerlink" title="应用4.按键控制LED"></a>应用4.按键控制LED</h3><p>面包板连接图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb1b00871b83018a6de942.jpg'><img src="https://pic.imgdb.cn/item/65bb1b00871b83018a6de942.jpg" alt="按键控制LED"></p><p>连接完成品如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg'><img src="https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg" alt="L按键控制led实物图"></p><p>为了保持主函数整洁，将部分代码封装到头文件Key.c和LED.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Key.c">#include &quot;stm32f10x.h&quot;                  // Device header<br>#include &quot;Delay.h&quot;<br><br>/**<br>  * 函    数：按键初始化<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void Key_Init(void)<br>&#123;<br>/*开启时钟*/<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//开启GPIOB的时钟<br><br>/*GPIO初始化*/<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//将PB1和PB11引脚初始化为上拉输入<br>&#125;<br><br>/**<br>  * 函    数：按键获取键码<br>  * 参    数：无<br>  * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下<br>  * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手<br>  */<br>uint8_t Key_GetNum(void)<br>&#123;<br>uint8_t KeyNum = 0;//定义变量，默认键码值为0<br><br>if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)//读PB1输入寄存器的状态，如果为0，则代表按键1按下<br>&#123;<br>Delay_ms(20);//延时消抖<br>while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);//等待按键松手<br>Delay_ms(20);//延时消抖<br>KeyNum = 1;//置键码为1<br>&#125;<br><br>if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)//读PB11输入寄存器的状态，如果为0，则代表按键2按下<br>&#123;<br>Delay_ms(20);//延时消抖<br>while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);//等待按键松手<br>Delay_ms(20);//延时消抖<br>KeyNum = 2;//置键码为2<br>&#125;<br><br>return KeyNum;//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs LED.c">#include &quot;stm32f10x.h&quot;                  // Device header<br><br>/**<br>  * 函    数：LED初始化<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED_Init(void)<br>&#123;<br>/*开启时钟*/<br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//开启GPIOA的时钟<br><br>/*GPIO初始化*/<br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//将PA1和PA2引脚初始化为推挽输出<br><br>/*设置GPIO初始化后的默认电平*/<br>GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);//设置PA1和PA2引脚为高电平<br>&#125;<br><br>/**<br>  * 函    数：LED1开启<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_ON(void)<br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_1);//设置PA1引脚为低电平<br>&#125;<br><br>/**<br>  * 函    数：LED1关闭<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_OFF(void)<br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_1);//设置PA1引脚为高电平<br>&#125;<br><br>/**<br>  * 函    数：LED1状态翻转<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_Turn(void)<br>&#123;<br>if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)//获取输出寄存器的状态，如果当前引脚输出低电平<br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_1);//则设置PA1引脚为高电平<br>&#125;<br>else//否则，即当前引脚输出高电平<br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_1);//则设置PA1引脚为低电平<br>&#125;<br>&#125;<br><br>/**<br>  * 函    数：LED2开启<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_ON(void)<br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_2);//设置PA2引脚为低电平<br>&#125;<br><br>/**<br>  * 函    数：LED2关闭<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_OFF(void)<br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_2);//设置PA2引脚为高电平<br>&#125;<br><br>/**<br>  * 函    数：LED2状态翻转<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_Turn(void)<br>&#123;<br>if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)//获取输出寄存器的状态，如果当前引脚输出低电平<br>&#123;                                                  <br>GPIO_SetBits(GPIOA, GPIO_Pin_2);               //则设置PA2引脚为高电平<br>&#125;                                                  <br>else                                               //否则，即当前引脚输出高电平<br>&#123;                                                  <br>GPIO_ResetBits(GPIOA, GPIO_Pin_2);             //则设置PA2引脚为低电平<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs main.c">#include &quot;stm32f10x.h&quot;                  // Device header<br>#include &quot;Delay.h&quot;<br>#include &quot;LED.h&quot;<br>#include &quot;Key.h&quot;<br><br>uint8_t KeyNum;//定义用于接收按键键码的变量<br><br>int main(void)<br>&#123;<br>/*模块初始化*/<br>LED_Init();//LED初始化<br>Key_Init();//按键初始化<br><br>while (1)<br>&#123;<br>KeyNum = Key_GetNum();//获取按键键码<br><br>if (KeyNum == 1)//按键1按下<br>&#123;<br>LED1_Turn();//LED1翻转<br>&#125;<br><br>if (KeyNum == 2)//按键2按下<br>&#123;<br>LED2_Turn();//LED2翻转<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>具体功能见注释，通过这几个程序可以做到使用按键控制LED亮灭。</p><h3 id="应用5-光敏传感器控制蜂鸣器"><a href="#应用5-光敏传感器控制蜂鸣器" class="headerlink" title="应用5.光敏传感器控制蜂鸣器"></a>应用5.光敏传感器控制蜂鸣器</h3><p>接线图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb1b00871b83018a6deb22.jpg'><img src="https://pic.imgdb.cn/item/65bb1b00871b83018a6deb22.jpg" alt="光敏传感器控制蜂鸣器"></p><p>连接完成后实物图如下：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg'><img src="https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg" alt="光敏传感器控制蜂鸣器实物图"></p><p>头文件：<br>LightSensor.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：光敏传感器初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LightSensor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);<span class="hljs-comment">//开启GPIOB的时钟</span><br><br><span class="hljs-comment">/*GPIO初始化*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOB, &amp;GPIO_InitStructure);<span class="hljs-comment">//将PB13引脚初始化为上拉输入</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：获取当前光敏传感器输出的高低电平</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：光敏传感器输出的高低电平，范围：0/1</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">LightSensor_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);<span class="hljs-comment">//返回PB13输入寄存器的状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>LED.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="hljs-comment">//开启GPIOA的时钟</span><br><br><span class="hljs-comment">/*GPIO初始化*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="hljs-comment">//将PA1和PA2引脚初始化为推挽输出</span><br><br><span class="hljs-comment">/*设置GPIO初始化后的默认电平*/</span><br>GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);<span class="hljs-comment">//设置PA1和PA2引脚为高电平</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1开启</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_ON</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_1);<span class="hljs-comment">//设置PA1引脚为低电平</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1关闭</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_OFF</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_1);<span class="hljs-comment">//设置PA1引脚为高电平</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1状态翻转</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_Turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == <span class="hljs-number">0</span>)<span class="hljs-comment">//获取输出寄存器的状态，如果当前引脚输出低电平</span><br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_1);<span class="hljs-comment">//则设置PA1引脚为高电平</span><br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//否则，即当前引脚输出高电平</span><br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_1);<span class="hljs-comment">//则设置PA1引脚为低电平</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2开启</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_ON</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_ResetBits(GPIOA, GPIO_Pin_2);<span class="hljs-comment">//设置PA2引脚为低电平</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2关闭</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_OFF</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>GPIO_SetBits(GPIOA, GPIO_Pin_2);<span class="hljs-comment">//设置PA2引脚为高电平</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2状态翻转</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_Turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == <span class="hljs-number">0</span>)<span class="hljs-comment">//获取输出寄存器的状态，如果当前引脚输出低电平</span><br>&#123;                                                  <br>GPIO_SetBits(GPIOA, GPIO_Pin_2);               <span class="hljs-comment">//则设置PA2引脚为高电平</span><br>&#125;                                                  <br><span class="hljs-keyword">else</span>                                               <span class="hljs-comment">//否则，即当前引脚输出高电平</span><br>&#123;                                                  <br>GPIO_ResetBits(GPIOA, GPIO_Pin_2);             <span class="hljs-comment">//则设置PA2引脚为低电平</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buzzer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;LightSensor.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*模块初始化*/</span><br>Buzzer_Init();<span class="hljs-comment">//蜂鸣器初始化</span><br>LightSensor_Init();<span class="hljs-comment">//光敏传感器初始化</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (LightSensor_Get() == <span class="hljs-number">1</span>)<span class="hljs-comment">//如果当前光敏输出1</span><br>&#123;<br>Buzzer_ON();<span class="hljs-comment">//蜂鸣器开启</span><br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//否则</span><br>&#123;<br>Buzzer_OFF();<span class="hljs-comment">//蜂鸣器关闭</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>OLED(Organic Light Emitting Diode)<br>供电：3-5.5V，通信协议：I2C&#x2F;SPI，分辨率：128*64（0.96寸）</p><p>OLED显示屏电路原理图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23b659f345e8d03771dd7.png'><img src="https://pic.imgdb.cn/item/65c23b659f345e8d03771dd7.png" alt="4针脚OLED"></p><p class='item-img' data-src='https://pic.imgdb.cn/item/65c23b659f345e8d03771eab.png'><img src="https://pic.imgdb.cn/item/65c23b659f345e8d03771eab.png" alt="7针脚OLED"></p><h3 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h3><ol><li>串口调试：通过串口通信将调试信息发送到电脑端，电脑使用串口助手显示调试信息</li><li>显示屏调试：将显示屏连到单片机，将调试信息直接在显示屏上显示</li><li>Keil调试模式：借助keil软件的调试功能，可使用单步运行、设置断点、查看寄存器以及变量等功能（调试模式下不能修改代码）</li></ol><h3 id="驱动函数"><a href="#驱动函数" class="headerlink" title="驱动函数"></a>驱动函数</h3><p>将OLED显示屏区分为4行16列</p><p>教程给出的函数有：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">OLED_Init()</td><td align="center">初始化</td></tr><tr><td align="center">OLED_Clear()</td><td align="center">清屏</td></tr><tr><td align="center">OLED_ShowChar(1,1,’A’)</td><td align="center">显示一个字符</td></tr><tr><td align="center">OLED_ShowString(1,3,”HelloWorld”)</td><td align="center">显示字符串</td></tr><tr><td align="center">OLED_ShowNum(2,1,12345,5)</td><td align="center">显示十进制数字</td></tr><tr><td align="center">OLED_ShowSignedNum(2,7,-66,2)</td><td align="center">显示有符号十进制数</td></tr><tr><td align="center">OLED_ShowHexNum(3,1,0xAA55,4)</td><td align="center">显示16进制数字</td></tr><tr><td align="center">OLED_ShowBinNum(4,1,0xAA55,16)</td><td align="center">显示2进制数字</td></tr></tbody></table><h3 id="实体演示"><a href="#实体演示" class="headerlink" title="实体演示"></a>实体演示</h3><p>面包板接线图 ；<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg'><img src="https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg" alt="OLED"></p><p>编写如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br><br>    OLED_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Homo&quot;</span>);<br>    OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">114</span>,<span class="hljs-number">3</span>);<br>    OLED_ShowHexNum(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x514</span>,<span class="hljs-number">3</span>);<br>    OLED_ShowSignedNum(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-19198</span>,<span class="hljs-number">5</span>);<br>    OLED_ShowBinNum(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>   <br>       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显示结果如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c241b89f345e8d03908e37.jpg'><img src="https://pic.imgdb.cn/item/65c241b89f345e8d03908e37.jpg" alt="OLED显示"></p><p><em><del>莫名感觉有点可爱</del></em></p><h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>EXTI(Extern Interrupt)外部中断</p><p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO产生电平变化时，EXTI会立刻向NVIC发出中断申请，经NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p><p>支持的触发方式：上升沿&#x2F;下降沿&#x2F;双边沿&#x2F;软件触发</p><p>支持全部GPIO口，但是相同的Pin不能同时触发中断</p><p>通道数：16个GPIO，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p><p>触发相应方式：中断响应&#x2F;事件响应（中断响应是触发中断，事件响应是触发别的外设操作）</p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>中断：主程序运行时出现了特定的中断触发条件（中断源），使CPU暂停当前程序转去处理中断程序，处理完之后返回暂停位置继续执行原本程序</p><p>中断优先级：多个中断源同时申请中断的时候，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p><p>中断嵌套：一个中断正在运行的时候，有优先级更高的中断源申请中断的时候，CPU会再次暂停当前中断程序，转去处理新的中断程序，处理完之后依次返回</p><p>STM32中断包括：EXTI,TIM,ADC,USRT,SPI,I2C,PTC</p><p>中断向量表：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e7d8.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e7d8.png" alt="中断表1"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e8ae.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e8ae.png" alt="中断表2"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e705.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e705.png" alt="中断表3"></p><h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><h4 id="NVIC基本结构"><a href="#NVIC基本结构" class="headerlink" title="NVIC基本结构"></a>NVIC基本结构</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65c389a89f345e8d03c63895.png'><img src="https://pic.imgdb.cn/item/65c389a89f345e8d03c63895.png" alt="NVIC_Basic_Structure"></p><p>使用NVIC为了防止中断占用过多CPU引脚以及防止优先级分组对CPU性能的占用</p><h4 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h4><p>NVIC的中断优先级由优先级寄存器的四位（0-15）组成，这四位可以进行切分，分成高n位的抢占优先级和低4-n位的相应优先级</p><p>抢断优先级高的可以中断嵌套，响应优先级高的可以优先排队，两者相同按中断号排队</p><h3 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h3><h4 id="EXTI基本结构"><a href="#EXTI基本结构" class="headerlink" title="EXTI基本结构"></a>EXTI基本结构</h4><p>结构框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c394939f345e8d03f54378.png'><img src="https://pic.imgdb.cn/item/65c394939f345e8d03f54378.png" alt="EXTI结构框图"></p><p>AFIO是一个数据选择器，他会选择前面连接的一个引脚连接到EXTI，这也是为什么前面说每个引脚只能连接一个中断。</p><p>*注：原本EXTI有20路通道输出，但是其中5-9，10-15分别被集中到一个引脚中，即5-9，10-15分别会触发同一个中断函数，在这两个中断函数中，我们要通过标志位来判断具体是哪个中断</p><p>下面还有20个引脚连接外设</p><h4 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h4><p>AFIO电路图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c397849f345e8d0301f25a.png'><img src="https://pic.imgdb.cn/item/65c397849f345e8d0301f25a.png" alt="AFIO"></p><p>AFIO主要用于引脚复用功能的选择和重定义</p><p>在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p><h4 id="EXTI内部框图"><a href="#EXTI内部框图" class="headerlink" title="EXTI内部框图"></a>EXTI内部框图</h4><p>EXTI内部框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c397e49f345e8d03039d26.png'><img src="https://pic.imgdb.cn/item/65c397e49f345e8d03039d26.png" alt="EXTI内部框图"></p><p>图中右下角输入线就是20根输入线，通过检测器决定是进行上升沿触发&#x2F;下降沿触发&#x2F;两者</p><p>请求挂起寄存器可以被读取以判断是哪个通道触发的判断</p><p>· 需要使用外部中断的情况：外部驱动的突发事件</p><h3 id="旋转编码器介绍"><a href="#旋转编码器介绍" class="headerlink" title="旋转编码器介绍"></a>旋转编码器介绍</h3><p>旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</p><p>类型：机械触点式&#x2F;霍尔传感器式&#x2F;光栅式</p><p>光栅式：通过旋钮上光栅阻挡信号产生信号波，但是只能测位置和速度不能测方向</p><p>机械触电式：金属触点经过设计，正反转时。两个触电会有不同的相位差，通过相位差可以判断方向</p><p>硬件电路：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c39b849f345e8d0314285b.png'><img src="https://pic.imgdb.cn/item/65c39b849f345e8d0314285b.png" alt="旋转编码器模块"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c39b839f345e8d03142795.png'><img src="https://pic.imgdb.cn/item/65c39b839f345e8d03142795.png" alt="旋转编码器"></p><h3 id="应用1-对射式红外传感器计次"><a href="#应用1-对射式红外传感器计次" class="headerlink" title="应用1.对射式红外传感器计次"></a>应用1.对射式红外传感器计次</h3><p>面包板连接图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c4469b9f345e8d038e92cd.jpg'><img src="https://pic.imgdb.cn/item/65c4469b9f345e8d038e92cd.jpg" alt="对射式红外传感器计次"></p><p>头文件：<br>CountSensor.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> CounterSensor_Count;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CounterSensor_Init</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//基础配置</span><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-comment">//配置AFIO</span><br>    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);<br><br>    <span class="hljs-comment">//配置EXTI</span><br>    EXTI_InitTypeDef EXTI_InitStructure;<br>    EXTI_InitStructure.EXTI_Line=EXTI_Line14;<br>    EXTI_InitStructure.EXTI_LineCmd=ENABLE;<br>    EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<br>    EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<br>    EXTI_Init(&amp;EXTI_InitStructure);<br><br>    <span class="hljs-comment">//配置NVIC</span><br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br><br>    NVIC_InitTypeDef NVIC_InitStructure;<br>    NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="hljs-number">1</span>;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="hljs-number">1</span>;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>&#125;<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CountSensor_GetCount</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> CounterSensor_Count;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(EXTI_GetITStatus(EXTI_Line14)==SET)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_14)==<span class="hljs-number">0</span>)<br>        &#123;<br>            CounterSensor_Count++;<br>        &#125;<br>        EXTI_ClearITPendingBit(EXTI_Line14);<br>        <br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>主程序：<br>main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CountSensor.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    CounterSensor_Init();<br><br>    OLED_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,CountSensor_GetCount(),<span class="hljs-number">5</span>);<br>       <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现象：每次对射式红外传感器中间被隔光，OLED上显示次数+1</p><h3 id="应用2-旋转编码器计次"><a href="#应用2-旋转编码器计次" class="headerlink" title="应用2.旋转编码器计次"></a>应用2.旋转编码器计次</h3><p>面包板接线图：<br>![旋转编码计数器](<a href="https://pic/">https://pic</a> .imgdb.cn&#x2F;item&#x2F;65c481509f345e8d03201b8a.jpg)</p><h2 id="TIM定时器中断"><a href="#TIM定时器中断" class="headerlink" title="TIM定时器中断"></a>TIM定时器中断</h2><h3 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h3><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断<br>16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p><p>不仅具备基本的定时中断功能，而且还包含<strong>内外时钟源选择</strong>、<strong>输入捕获</strong>、<strong>输出比较</strong>、<strong>编码器接口</strong>、<strong>主从触发模式</strong>等多种功能</p><p>根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p><table><thead><tr><th align="center">类型</th><th align="center">编号</th><th align="center">总线</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">高级定时器</td><td align="center">TIM1、TIM8</td><td align="center">APB2</td><td align="center">拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td></tr><tr><td align="center">通用定时器</td><td align="center">TIM2、TIM3、TIM4、TIM5</td><td align="center">APB1</td><td align="center">拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td></tr><tr><td align="center">基本定时器</td><td align="center">TIM6、TIM7</td><td align="center">APB1</td><td align="center">拥有定时中断、主模式触发DAC的功能</td></tr></tbody></table><p><em>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4</em></p><h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6dd629f345e8d03404c71.png'><img src="https://pic.imgdb.cn/item/65c6dd629f345e8d03404c71.png" alt="基本定时器框图"></p><p>PSC预分频器：输出频率&#x3D;输入频率&#x2F;输入的值</p><p>自动重装寄存器记录写入的计数目标，当计数&#x3D;&#x3D;技术目标的时候产生一个中断信号并清零计数器</p><p>此类计数值等于自动重装值产生的中断叫做“更新中断”</p><h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6e0099f345e8d03451c35.png'><img src="https://pic.imgdb.cn/item/65c6e0099f345e8d03451c35.png" alt="通用定时器结构框图"></p><p>通用定时器除了向上计数（从0开始累计到重装值之后清零同时申请中断），还支持向下计数（从重装值开始递减，到0之后回到重装值并申请中断）和中央对齐计数（先从0向上到重装值申请中断然后从重装值向下到0再申请中断，依次循环），高级计时器也支持这三类模式</p><p>除了使用内部72Hz的时钟，还可以通过ETR连接外部时钟（通过ETRF作为时钟使用较简单，通过TRGI会占据通道</p><p>ITR引脚来自其他定时器的TRGO输出</p><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6e0099f345e8d03451bf0.png'><img src="https://pic.imgdb.cn/item/65c6e0099f345e8d03451bf0.png" alt="高级定时器结构框图"></p><p>基本和通用计时器只能每个计数周期发生一次中断，但是高级计时器可以使用重复次数计时器完成多个技术周期进行一次中断</p><h3 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c7231d9f345e8d03e08e35.jpg'><img src="https://pic.imgdb.cn/item/65c7231d9f345e8d03e08e35.jpg" alt="定时中断基本结构框图"></p><p>预分频器时序图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c727b79f345e8d03ed9243.png'><img src="https://pic.imgdb.cn/item/65c727b79f345e8d03ed9243.png" alt="预分频器时序图"></p><p>预分频器原理：在TIMx_PSC中写入新数据后（改变预分频值），控制，直到当前计数周期结束之后，改变的分频值才会起作用</p><p>预分频计数器内部也是靠计数器工作的，分频值为0时，计数器恒为0，分频值为1时，计数器就01计数，回到0时发出一个脉冲，定时器时钟计数。</p><p>计数器计数频率：CK_CNT&#x3D;CK_PSC&#x2F;(PSC+1)</p><h3 id="计时器时序"><a href="#计时器时序" class="headerlink" title="计时器时序"></a>计时器时序</h3><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/7b9477f8c3680db0ed6dd185117bfc5d.png'><img src="https://www.z4a.net/images/2024/02/10/7b9477f8c3680db0ed6dd185117bfc5d.png" alt="计时器时序"></p><p><em>UIF需要在中断程序中手动清零</em></p><p>计数器溢出频率：CK_CNT_OV&#x3D;CK_CNT&#x2F;(ARR+1)&#x3D;CK_PSC&#x2F;(PSC+1)&#x2F;(ARR+1)</p><h4 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h4><p>计数器中有缓冲计时器，可以通过修改APRE的值控制是否使用</p><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/486e8a762680ca8177d762e5320e2bea.png'><img src="https://www.z4a.net/images/2024/02/10/486e8a762680ca8177d762e5320e2bea.png" alt="计数器无预装时序"></p><p>在无预装时许的情况下修改技术目标，若当前计数值小于技术目标，则到达修改后的计数目标然后重置，若大于，则会因为无法等于技术目标而一直到上限再重置 </p><h4 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h4><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/02b5e9f258121466ddaae53f4cc650e7.png'><img src="https://www.z4a.net/images/2024/02/10/02b5e9f258121466ddaae53f4cc650e7.png" alt="计数器有预装时时序"></p><p>影子计数器用于同步防止出错</p><h3 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h3><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/RCC.png'><img src="https://www.z4a.net/images/2024/02/10/RCC.png" alt="RCC时钟树"></p><p>在不修改参数的情况下，三种计时器都是72Hz</p><h3 id="应用1-定时器定时中断"><a href="#应用1-定时器定时中断" class="headerlink" title="应用1.定时器定时中断"></a>应用1.定时器定时中断</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg'><img src="https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg" alt="定时器定时中断"></p><p>头文件Timer.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> Num;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TImer_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br><br>    TIM_InternalClockConfig(TIM2);<br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">10000</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">7200</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ClearFlag(TIM2,TIM_FLAG_Update);<br>    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<br><br>    NVIC_InitTypeDef NVIC_InitStructure;<br>    NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="hljs-number">2</span>;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="hljs-number">1</span>;<br>    NVIC_Init(&amp;NVIC_InitStructure); <br><br>    TIM_Cmd(TIM2,ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)<br>    &#123;<br>        Num++;<br>        TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>主程序 main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timer.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> Num;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    OLED_Init();<br>    TImer_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Num:&quot;</span>);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Num,<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用2-定时器外部时钟"><a href="#应用2-定时器外部时钟" class="headerlink" title="应用2.定时器外部时钟"></a>应用2.定时器外部时钟</h3><p>面包板接线图：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3c9f345e8d034904a2.jpg'><img src="https://pic.imgdb.cn/item/65c86f3c9f345e8d034904a2.jpg" alt="定时器外部时钟"></p><h3 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h3><h4 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h4><p>·OC（Output Compare） 输出比较可以通过比较CNT和CRR寄存器值的关系来输出电平进行置0、置1或反转的操作，用于输出一点频率和占空比的PWM波形<br>·每个高级定时器和通用定时器都有4个输出比较通道<br>·高级定时器的前三个通道额外拥有死区生成和互补输出的功能</p><h4 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h4><p>PWM(Pluse Width Modulation)脉冲宽度调制<br>在具有惯性的系统中，可通过对一系列脉冲的宽度进行调制来等效的获取需要的模拟参量，常用于电机控速等领域<br>PWM参数：<br>  频率&#x3D;1&#x2F;T_s  占空比&#x3D;T_ON&#x2F;T_s  分辨率&#x3D;占空比变化步距</p><h4 id="输出比较通道"><a href="#输出比较通道" class="headerlink" title="输出比较通道"></a>输出比较通道</h4><p>下图是输出比较通道框图（高级和普通）</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b6e2.png'><img src="https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b6e2.png" alt="输出比较通道(high)"></p><p>为了控制电机，高级输出比较通道的OC1和OC1N需要输出互补的信号，在实际应用中可能会因为元件的不理想，导致出现上管未关闭下管就导通的现象，会导致功率损耗产生大量热，为防止该现象使用死区发生器，可以在一管关闭时延迟一段时间再导通另一管，避免同时导通。</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b77d.png'><img src="https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b77d.png" alt="输出比较通道(normal)"></p><p>通过比较CNT和CCR可以使输出模式控制器输出高低电平，通过调节寄存器可以选择不同模式，模式表如下:</p><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">冻结</td><td align="center">CNT&#x3D;CCR时，REF保持为原状态</td></tr><tr><td align="center">匹配时置有效电平</td><td align="center">CNT&#x3D;CCR时，REF置有效电平</td></tr><tr><td align="center">匹配时置有效电平</td><td align="center">CNT&#x3D;CCR时，REF置无效电平</td></tr><tr><td align="center">匹配时电平翻转</td><td align="center">CNT&#x3D;CCR时，REF电平翻转</td></tr><tr><td align="center">强制为无效电平</td><td align="center">CNT与CCR无效，REF强制为无效电平</td></tr><tr><td align="center">强制为有效电平</td><td align="center">CNT与CCR无效，REF强制为有效电平</td></tr><tr><td align="center">PWM模式1</td><td align="center">向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平   向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平</td></tr><tr><td align="center">PWM模式2</td><td align="center">向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平   向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平</td></tr></tbody></table><p>匹配时电平翻转模式可以平稳输出占空比为50%的信号，匹配时置有效电平和匹配时置有效电平相对不适合输出连续信号，比较适用于当你想要输出某一信号的情况</p><h4 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h4><p>PWM基本结构框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cb24079f345e8d0380c94b.png'><img src="https://pic.imgdb.cn/item/65cb24079f345e8d0380c94b.png" alt="PWM基本结构框图"></p><p>由图可以看出PWM的基本结构</p><h4 id="PWM参数计算"><a href="#PWM参数计算" class="headerlink" title="PWM参数计算"></a>PWM参数计算</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb24079f345e8d0380c9e5.png'><img src="https://pic.imgdb.cn/item/65cb24079f345e8d0380c9e5.png" alt="PWM波"></p><ol><li>PWM频率：  Freq &#x3D; CK_PSC&#x2F;(PSC+1)&#x2F;(ARR+1)</li><li>PWM占空比：Duty &#x3D; CRR&#x2F;(ARR+1)</li><li>PWM分辨率：Reso &#x3D; 1&#x2F;(ARR+1)</li></ol><h3 id="舵机简介"><a href="#舵机简介" class="headerlink" title="舵机简介"></a>舵机简介</h3><p>舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p><p>输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a619f345e8d0393dff2.png'><img src="https://pic.imgdb.cn/item/65cb2a619f345e8d0393dff2.png" alt="舵机"></p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a609f345e8d0393dd00.png'><img src="https://pic.imgdb.cn/item/65cb2a609f345e8d0393dd00.png" alt="舵机拆解图"></p><p>如图：舵机不是单纯的电机，而是由多个期间组成，大概逻辑就是PWM波给电板一个指定角度，判断当前角度，大则反转小则正转</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a609f345e8d0393ddb0.png'><img src="https://pic.imgdb.cn/item/65cb2a609f345e8d0393ddb0.png" alt="多舵机信号"></p><p>↑根据该图可以得到输入信号脉冲宽度对应的舵机输出角度</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a7738.png'><img src="https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a7738.png" alt="舵机硬件图"></p><p>在上面图片蓝色舵机的三个引线中，棕色是GND，红色是电源，黄色是信号线，不同型号的舵机可以参考元件的说明书</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a76ee.png'><img src="https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a76ee.png" alt="舵机电路图"></p><p>给舵机供电时需要看电源是否达标</p><h3 id="直流电机及驱动"><a href="#直流电机及驱动" class="headerlink" title="直流电机及驱动"></a>直流电机及驱动</h3><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec4d9.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec4d9.png" alt="直流电机"></p><p>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作</p><p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec5e9.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec5e9.png" alt="直流电机驱动"></p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec52f.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec52f.png" alt="直流电机电路"></p><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af65.png'><img src="https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af65.png" alt="驱动电路硬件模块"></p><p>VM是电机电源，需要一个能输出大电流的电源，VCC是逻辑电平输入，需要和控制器电压相同<br>AO和BO是电机输出，PWMA，AIN1，AIN2是AO1&#x2F;2对应的控制，其中PWMA接PWM信号输出端。<br>STBY是待机控制，接地待机，接VCC启动，需要时可以接GPIO控制<br>详细见下表：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af06.png'><img src="https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af06.png" alt="电机驱动表"></p><h3 id="应用3-PWM驱动LED呼吸灯"><a href="#应用3-PWM驱动LED呼吸灯" class="headerlink" title="应用3.PWM驱动LED呼吸灯"></a>应用3.PWM驱动LED呼吸灯</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f399f345e8d0348fd06.jpg'><img src="https://pic.imgdb.cn/item/65c86f399f345e8d0348fd06.jpg" alt="接线图"></p><p>头文件 PWM.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<br>    GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);<br>    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_15;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM2);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">100</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">7200</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">0</span>;<br>    TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2,ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_SetCompare1</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> Compare)</span><br>&#123;<br>    TIM_SetCompare1(TIM2,Compare);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主程序 mian.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    PWM_Init();<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            PWM_SetCompare1(i);<br>            Delay_ms(<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        &#123;<br>            PWM_SetCompare1(<span class="hljs-number">100</span>-i);<br>            Delay_ms(<span class="hljs-number">10</span>);<br>        &#125;<br>       <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总体步骤和51单片机呼吸灯相似</p><h3 id="应用4-PWM驱动电机"><a href="#应用4-PWM驱动电机" class="headerlink" title="应用4.PWM驱动电机"></a>应用4.PWM驱动电机</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3a9f345e8d0348ff42.jpg'><img src="https://pic.imgdb.cn/item/65c86f3a9f345e8d0348ff42.jpg" alt="PWM驱动电机"></p><p>所有PWM通道输出信号跳变都是同步的，所以可以四个一起用</p><p>头文件 PWM.c（有更改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    <span class="hljs-comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br>    <span class="hljs-comment">// GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br>    <span class="hljs-comment">// GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span><br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM2);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">2000</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">0</span>;<br>    TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2,ENABLE);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_SetCompare2</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> Compare)</span><br>&#123;<br>    TIM_SetCompare2(TIM2,Compare);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Servo.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Servo_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    PWM_Init();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Servo_SetAngle</span><span class="hljs-params">(<span class="hljs-type">float</span> Angle)</span><br>&#123;<br>    PWM_SetCompare2(Angle/<span class="hljs-number">100</span>*<span class="hljs-number">2000</span>+<span class="hljs-number">500</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主程序 main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Servo.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Key.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> KeyNum;<br><span class="hljs-type">float</span> Angle=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    Key_Init();<br>    Servo_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Angle:&quot;</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        OLED_ShowSignedNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Angle,<span class="hljs-number">3</span>);<br>        KeyNum=Key_GetNum();<br>        <span class="hljs-keyword">if</span> (KeyNum==<span class="hljs-number">1</span>)<br>        &#123;<br>             Angle+=<span class="hljs-number">10</span>;<br>             <span class="hljs-keyword">if</span> (Angle&gt;=<span class="hljs-number">90</span>)<br>             &#123;<br>                 Angle=<span class="hljs-number">0</span>;<br>             &#125;<br>             Servo_SetAngle(Angle);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="应用5-PWM驱动直流电机"><a href="#应用5-PWM驱动直流电机" class="headerlink" title="应用5.PWM驱动直流电机"></a>应用5.PWM驱动直流电机</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3b9f345e8d0349012e.jpg'><img src="https://pic.imgdb.cn/item/65c86f3b9f345e8d0349012e.jpg" alt="PWM驱动直流电机"></p><p>头文件<br>Motor.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Motor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4 | GPIO_Pin_5;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    PWM_Init();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Motor_SetSpeed</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> Speed)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (Speed &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        GPIO_SetBits(GPIOA,GPIO_Pin_4);<br>        GPIO_ResetBits(GPIOA,GPIO_Pin_5);<br>        PWM_SetCompare3(Speed);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        GPIO_ResetBits(GPIOA,GPIO_Pin_4);<br>        GPIO_SetBits(GPIOA,GPIO_Pin_5);<br>        PWM_SetCompare3(-Speed);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>主程序<br>mian.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Motor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Key.h&quot;</span></span><br><br><span class="hljs-type">uint8_t</span> KeyNum;<br><span class="hljs-type">int8_t</span> Speed;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    Motor_Init();<br>    Key_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Speed:&quot;</span>);<br>    Motor_SetSpeed(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        KeyNum=Key_GetNum();<br>        <span class="hljs-keyword">if</span> (KeyNum==<span class="hljs-number">1</span>)<br>        &#123;<br>            Speed+=<span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">if</span> (Speed&gt;<span class="hljs-number">100</span>)<br>            &#123;<br>                Speed=<span class="hljs-number">-100</span>;<br>            &#125;  <br>        &#125;<br>        Motor_SetSpeed(Speed);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Speed,<span class="hljs-number">3</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若电机旋转方向和自己想要的不一致可以更改Motor.c里面的Motor_SetSpeed函数</p><h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><p>IC(Input Compare)输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p><p>每个高级定时器和通用定时器都拥有4个输入捕获通道</p><p>可配置为PWMI模式，同时测量频率和占空比</p><p>可配合主从触发模式，实现硬件全自动测量</p><h4 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf09019f345e8d0389ef34.png'><img src="https://pic.imgdb.cn/item/65cf09019f345e8d0389ef34.png" alt="频率测量"></p><p>测频法：在闸门时间T内，对上升沿计次，得到N，则频率<br>$f_x&#x3D;\frac{N}{T}$</p><p>测频法适合高频</p><p>测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率<br>$f_x&#x3D;\frac{f_c}{N}$</p><p>测周法适合低频</p><p>在上述的两种方法中，N越大，误差越大，在某个频率下测频法和测周法的N相同，此频率为中界频率</p><p>中界频率：测频法与测周法误差相等的频率点<br>$f_m&#x3D;\sqrt{\frac{f_c}{T}}$</p><h4 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf15089f345e8d03b1364c.png'><img src="https://pic.imgdb.cn/item/65cf15089f345e8d03b1364c.png" alt="输入捕获通道"></p><h3 id="应用6-输入捕获模式测频率"><a href="#应用6-输入捕获模式测频率" class="headerlink" title="应用6.输入捕获模式测频率"></a>应用6.输入捕获模式测频率</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg'><img src="https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg" alt="输入捕获模式测频率"></p><p>头文件<br>IC.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM3);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">65536</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ICInitTypeDef TIM_ICInitStructure;<br>    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<br>    TIM_ICInitStructure.TIM_ICFilter=<span class="hljs-number">0xF</span>;<br>    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;<br>    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;<br>    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;<br>    TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);<br><br>    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);<br>    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);<br><br>    TIM_Cmd(TIM3,ENABLE);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主程序<br>mian.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IC.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    PWM_Init();<br>IC_Init();<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Freq:00000Hz&quot;</span>);<br><br>    PWM_SetPrescaler(<span class="hljs-number">720</span><span class="hljs-number">-1</span>);<br>    PWM_SetCompare1(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,IC_GetFreq(),<span class="hljs-number">5</span>);<br>       <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="应用7-PWMI模式测占空比"><a href="#应用7-PWMI模式测占空比" class="headerlink" title="应用7.PWMI模式测占空比"></a>应用7.PWMI模式测占空比</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg'><img src="https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg" alt="PWMI模式测占空比"></p><p>头文件：<br>IC.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM3);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">65536</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ICInitTypeDef TIM_ICInitStructure;<br>    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<br>    TIM_ICInitStructure.TIM_ICFilter=<span class="hljs-number">0xF</span>;<br>    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;<br>    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;<br>    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;<br>    TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);<br><br>    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);<br>    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);<br><br>    TIM_Cmd(TIM3,ENABLE);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetPuty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (TIM_GetCapture2(TIM3)+<span class="hljs-number">1</span>)*<span class="hljs-number">100</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主程序<br>mian.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PWM.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;IC.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    PWM_Init();<br>IC_Init();<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Freq:00000Hz&quot;</span>);<br>    OLED_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Duty:000%&quot;</span>);<br><br>    PWM_SetPrescaler(<span class="hljs-number">720</span><span class="hljs-number">-1</span>);<br>    PWM_SetCompare1(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,IC_GetFreq(),<span class="hljs-number">5</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,IC_GetPuty(),<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为没有信号发生器，所以这里的信号由GPIOA_PIN0产生的PW吗波代替</p><h3 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h3><p>编码器接口(Encoder Interface )可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p><p>每个高级定时器和通用定时器都拥有1个编码器接口</p><p>两个输入引脚借用了输入捕获的通道1和通道2</p><h4 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf64739f345e8d03d32021.png'><img src="https://pic.imgdb.cn/item/65cf64739f345e8d03d32021.png" alt="正交编码器"></p><p>由图：在正转时A相提前B相90°，反转时A相滞后B相90°（具体哪个提前哪个滞后可以自己改）</p><p>使用正交信号好处：</p><ol><li>更精确</li><li>抗噪声</li></ol><p>编码器接口基本结构：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf69749f345e8d03e9f226.png'><img src="https://pic.imgdb.cn/item/65cf69749f345e8d03e9f226.png" alt="编码器接口基本结构"></p><p>工作模式：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf6f289f345e8d0303e56d.png'><img src="https://pic.imgdb.cn/item/65cf6f289f345e8d0303e56d.png" alt="工作模式"></p><p>实例：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf6ff69f345e8d03073f38.png'><img src="https://pic.imgdb.cn/item/65cf6ff69f345e8d03073f38.png" alt="e.p.1"></p><p>通过调节IC1PF1可以使反向</p><p>实例（反向）:<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf70ea9f345e8d030b4162.png'><img src="https://pic.imgdb.cn/item/65cf70ea9f345e8d030b4162.png" alt="1.p.e"></p><h3 id="应用8-编码器接口测速"><a href="#应用8-编码器接口测速" class="headerlink" title="应用8.编码器接口测速"></a>应用8.编码器接口测速</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65d9814e9f345e8d0306048b.jpg'><img src="https://pic.imgdb.cn/item/65d9814e9f345e8d0306048b.jpg" alt="编码器接口测速"></p><p>头文件：Encoder.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：编码器初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encoder_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*开启时钟*/</span><br>RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);<span class="hljs-comment">//开启TIM3的时钟</span><br>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);<span class="hljs-comment">//开启GPIOA的时钟</span><br><br><span class="hljs-comment">/*GPIO初始化*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="hljs-comment">//将PA6和PA7引脚初始化为上拉输入</span><br><br><span class="hljs-comment">/*时基单元初始化*/</span><br>TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<span class="hljs-comment">//定义结构体变量</span><br>TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="hljs-comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span><br>TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="hljs-comment">//计数器模式，选择向上计数</span><br>TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">65536</span> - <span class="hljs-number">1</span>;               <span class="hljs-comment">//计数周期，即ARR的值</span><br>TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;                <span class="hljs-comment">//预分频器，即PSC的值</span><br>TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;            <span class="hljs-comment">//重复计数器，高级定时器才会用到</span><br>TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             <span class="hljs-comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span><br><br><span class="hljs-comment">/*输入捕获初始化*/</span><br>TIM_ICInitTypeDef TIM_ICInitStructure;<span class="hljs-comment">//定义结构体变量</span><br>TIM_ICStructInit(&amp;TIM_ICInitStructure);<span class="hljs-comment">//结构体初始化，若结构体没有完整赋值</span><br><span class="hljs-comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span><br><span class="hljs-comment">//避免结构体初值不确定的问题</span><br>TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;<span class="hljs-comment">//选择配置定时器通道1</span><br>TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br>TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;<span class="hljs-comment">//选择配置定时器通道2</span><br>TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br><br><span class="hljs-comment">/*编码器接口配置*/</span><br>TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br><span class="hljs-comment">//配置编码器模式以及两个输入通道是否反相</span><br><span class="hljs-comment">//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相</span><br><span class="hljs-comment">//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置</span><br><br><span class="hljs-comment">/*TIM使能*/</span><br>TIM_Cmd(TIM3, ENABLE);<span class="hljs-comment">//使能TIM3，定时器开始运行</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：获取编码器的增量值</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：自上此调用此函数后，编码器的增量值</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">int16_t</span> <span class="hljs-title function_">Encoder_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*使用Temp变量作为中继，目的是返回CNT后将其清零*/</span><br><span class="hljs-type">int16_t</span> Temp;<br>Temp = TIM_GetCounter(TIM3);<br>TIM_SetCounter(TIM3, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> Temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>主程序：main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Encoder.h&quot;</span></span><br><br><span class="hljs-type">int16_t</span> Speed;<span class="hljs-comment">//定义速度变量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*模块初始化*/</span><br>OLED_Init();<span class="hljs-comment">//OLED初始化</span><br>Timer_Init();<span class="hljs-comment">//定时器初始化</span><br>Encoder_Init();<span class="hljs-comment">//编码器初始化</span><br><br><span class="hljs-comment">/*显示静态字符串*/</span><br>OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Speed:&quot;</span>);<span class="hljs-comment">//1行1列显示字符串Speed:</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>OLED_ShowSignedNum(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, Speed, <span class="hljs-number">5</span>);<span class="hljs-comment">//不断刷新显示编码器测得的最新速度</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：TIM2中断函数</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span><br><span class="hljs-comment">  *           函数名为预留的指定名称，可以从启动文件复制</span><br><span class="hljs-comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)<span class="hljs-comment">//判断是否是TIM2的更新事件触发的中断</span><br>&#123;<br>Speed = Encoder_Get();<span class="hljs-comment">//每隔固定时间段读取一次编码器计数增量值，即为速度值</span><br>TIM_ClearITPendingBit(TIM2, TIM_IT_Update);<span class="hljs-comment">//清除TIM2更新事件的中断标志位</span><br><span class="hljs-comment">//中断标志位必须清除</span><br><span class="hljs-comment">//否则中断将连续不断地触发，导致主程序卡死</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ADC-数模转换器"><a href="#ADC-数模转换器" class="headerlink" title="ADC 数模转换器"></a>ADC 数模转换器</h2><p>ADC（Analog-Digital Converter）模拟-数字转换器</p><p>ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p><p>12位逐次逼近型ADC，1us转换时间</p><p>输入电压范围：0<del>3.3V，转换结果范围：0</del>4095</p><p>18个输入通道，可测量16个外部和2个内部信号源</p><p>规则组和注入组两个转换单元</p><p>模拟看门狗自动监测输入电压范围</p><p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><h4 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d984c89f345e8d030f69d8.png'><img src="https://pic.imgdb.cn/item/65d984c89f345e8d030f69d8.png" alt="逐次逼近型ADC"></p><p>通道选择开关八个通道都可输入，地址锁存和译码可选择输入的通道</p><p>DAC输入的电压在比较器与通道进入的电压比较，逼近，直至大约相等，此时DAC电压等于输入电压，比较过程使用二分法</p><p>CLOCK是时钟，START是输入信号，EOC是输出信号</p><p>V_REF是参考电压</p><h4 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d986389f345e8d0313c539.png'><img src="https://pic.imgdb.cn/item/65d986389f345e8d0313c539.png" alt="ADC框图"></p><p>左侧ADCx_IN是输入口，经过选择器进入模数转换器（原理类似于上面逐次逼近型ADC），输出数据保存在寄存器，可以读取</p><p>在这个模型里，可以一次性选择多个通道，注入通道上限4个，规则通道上限16个</p><p>规则通道只有一个寄存器，所以直接使用会导致前面的数据丢失，只有最后的数据，常配合DMA使用，DMA可以将前面的数据移至其他地方存储。</p><p>为了减少对程序的影响，左下两个触发使用硬件触发，将TIM3设为TRGO，定时，就可以自动触发ADC转换，节省了触发资源</p><p>右上角模拟看门狗，可以设置模拟阈值，当达到阈值的时候就会申请NVIC的ADC中断，同样，（注入）转换结束也能申请中断</p><h4 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98a0c9f345e8d031ef502.png'><img src="https://pic.imgdb.cn/item/65d98a0c9f345e8d031ef502.png" alt="输入通道"></p><p><em>ADC1和ADC2可分开使用，也可以一起使用</em></p><h4 id="转换模式"><a href="#转换模式" class="headerlink" title="转换模式"></a>转换模式</h4><h5 id="单次转换非扫描模式"><a href="#单次转换非扫描模式" class="headerlink" title="单次转换非扫描模式"></a>单次转换非扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c1e3.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c1e3.png" alt="单次转换非扫描模式"></p><p>把想要转换的通道放在序列1，转换后数据存放在数据寄存器，通识EOC置1</p><h5 id="连续转换非扫描模式"><a href="#连续转换非扫描模式" class="headerlink" title="连续转换非扫描模式"></a>连续转换非扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c2d4.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c2d4.png" alt="连续转换非扫描模式"></p><p>连续转换不需要判断结束，需要数据直接读取</p><h5 id="单次转换扫描模式"><a href="#单次转换扫描模式" class="headerlink" title="单次转换扫描模式"></a>单次转换扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c25c.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c25c.png" alt="单次转换扫描模式"></p><p>设置通道数目，每次只转换通道数目对应数目的，全部完成之后EOC置1</p><h5 id="连续转换扫描模式"><a href="#连续转换扫描模式" class="headerlink" title="连续转换扫描模式"></a>连续转换扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c361.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c361.png" alt="连续转换扫描模式"></p><p>连续扫描</p><h4 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98cdf9f345e8d03273840.png'><img src="https://pic.imgdb.cn/item/65d98cdf9f345e8d03273840.png" alt="触发控制"></p><h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>分为<strong>数据右对齐</strong>和<strong>数据左对齐</strong>，分别为左侧和右侧补0，右对齐比较常用</p><h4 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h4><p>AD转换的步骤：采样，保持，量化，编码</p><p>STM32 ADC的总转换时间为：<br>    T_CONV &#x3D; 采样时间 + 12.5个ADC周期</p><p>例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期<br>    T_CONV &#x3D; 1.5 + 12.5 &#x3D; 14个ADC周期 &#x3D; 1μs</p><h4 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h4><p>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p><p>建议在每次上电后执行一次校准</p><p>启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p><h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98e219f345e8d032ac21c.png'><img src="https://pic.imgdb.cn/item/65d98e219f345e8d032ac21c.png" alt="硬件电路"></p><h3 id="应用1-AD单通道"><a href="#应用1-AD单通道" class="headerlink" title="应用1.AD单通道"></a>应用1.AD单通道</h3><p>面包板接线图：</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65db49e69f345e8d03468302.jpg'><img src="https://pic.imgdb.cn/item/65db49e69f345e8d03468302.jpg" alt="AD单通道"></p><p>头文件 AD.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    RCC_ADCCLKConfig(RCC_PCLK2_Div6);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="hljs-number">1</span>,ADC_SampleTime_55Cycles5);<br><br>    ADC_InitTypeDef ADC_InitStructure;<br>    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;<br>    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<br>    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<br>    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<br>    ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;<br>    ADC_InitStructure.ADC_ScanConvMode = DISABLE;<br>    ADC_Init(ADC1,&amp;ADC_InitStructure);<br><br>    ADC_Cmd(ADC1,ENABLE);<br><br>    ADC_ResetCalibration(ADC1);<br>    <span class="hljs-keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<br>    ADC_StartCalibration(ADC1);<br>    <span class="hljs-keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<br><br>    ADC_SoftwareStartConvCmd(ADC1,ENABLE);<br>&#125;<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">AD_GetValue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <br>    <span class="hljs-keyword">return</span> ADC_GetConversionValue(ADC1);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面程序配置的是连续模式，将init函数的最后一行移到getvalue函数的第一行并在后面加一行<code>    while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);</code>并将<code>    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</code>改为DISABLE即可改成非连续模式。</p><p>主程序 main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f10x.h&quot;</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;OLED.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AD.h&quot;</span></span><br><br><span class="hljs-type">uint16_t</span> ADVALUE;<br><span class="hljs-type">float</span> Voltage;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>OLED_Init();<br>    AD_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ADVALUE:&quot;</span>);<br>    OLED_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Voltage:&quot;</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        ADVALUE = AD_GetValue();<br>        Voltage = (<span class="hljs-type">float</span>)ADVALUE/<span class="hljs-number">4095</span>*<span class="hljs-number">3</span>;<br><br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,ADVALUE,<span class="hljs-number">4</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,Voltage,<span class="hljs-number">1</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,(<span class="hljs-type">uint16_t</span>)(Voltage*<span class="hljs-number">100</span>)%<span class="hljs-number">100</span>,<span class="hljs-number">3</span>);<br>        OLED_ShowChar(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;.&#x27;</span>);<br>        Delay_ms(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="应用2-AD多通道"><a href="#应用2-AD多通道" class="headerlink" title="应用2.AD多通道"></a>应用2.AD多通道</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65db52cc9f345e8d03629888.jpg'><img src="https://pic.imgdb.cn/item/65db52cc9f345e8d03629888.jpg" alt="AD多通道"></p><h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA（Direct Memory Access）直接存储器存取<br>DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源<br>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>每个通道都支持软件触发和特定的硬件触发</p><p>STM32F103C8T6 DMA资源：DMA1（7个通道）</p><h3 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h3><p>ROM：</p><table><thead><tr><th align="center">起始地址</th><th align="center">存储器</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">0x0800 0000</td><td align="center">程序存储器Flash</td><td align="center">存储C语言编译后的程序代码</td></tr><tr><td align="center">0x1FFF F000</td><td align="center">系统存储器</td><td align="center">存储BootLoader，用于串口下载</td></tr><tr><td align="center">0x1FFF F800</td><td align="center">选项字节</td><td align="center">存储一些独立于程序代码的配置参数</td></tr></tbody></table><h3 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed1f029f345e8d0359f9d4.png'><img src="https://pic.imgdb.cn/item/65ed1f029f345e8d0359f9d4.png" alt="DMA_Basic_Structure"></p><h3 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h3><p>这部分是上面DMA触发的内容</p><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed20519f345e8d0360b262.png'><img src="https://pic.imgdb.cn/item/65ed20519f345e8d0360b262.png" alt="DMA_Request"></p><p>M2M是选择位，选择硬件触发还是软件触发，EN是开关控制</p><h3 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed229d9f345e8d036cc68c.png'><img src="https://pic.imgdb.cn/item/65ed229d9f345e8d036cc68c.png" alt="数据转运+DMA"></p><h3 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed229d9f345e8d036cc82e.png'><img src="https://pic.imgdb.cn/item/65ed229d9f345e8d036cc82e.png" alt="ADC扫描模式+DMA"></p><p>其他模式下DMA作用类似于锦上添花，但是对于ADC而言DMA非常重要，没有DMA会使ADC功能大大受限，所以ADC+DMA是非常常见经典的组合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32学习笔记&quot;&gt;&lt;a href=&quot;#STM32学习笔记&quot; class=&quot;headerlink&quot; title=&quot;STM32学习笔记&quot;&gt;&lt;/a&gt;STM32学习笔记&lt;/h1&gt;&lt;p&gt;这个笔记是基于标准库的，跟随江协教程学习。&lt;/p&gt;
&lt;h2 id=&quot;1-新建工程&quot;&gt;</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="嵌入式" scheme="http://passengerdong.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://passengerdong.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>51单片机入门学习笔记</title>
    <link href="http://passengerdong.github.io/2023/11/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://passengerdong.github.io/2023/11/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-11-26T03:13:15.000Z</published>
    <updated>2024-11-18T15:32:29.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="51单片机学习笔记"><a href="#51单片机学习笔记" class="headerlink" title="51单片机学习笔记"></a>51单片机学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是我在学习51单片机时的笔记</p><p>学习视频链接：<a href="https://www.bilibili.com/video/BV1Mb411e7re/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=f9a3adbc69ab78cfe8e4d41440ea1b3e">51单片机入门教程-2020版 程序全程纯手打 从零开始入门</a></p><p>祝我学习顺利</p><h2 id="学习安排"><a href="#学习安排" class="headerlink" title="学习安排"></a>学习安排</h2><p>硬件要求：</p><p>51单片机一只（淘宝很多），Windows系统电脑一台（苹果叉出去）</p><p>软件要求：</p><p>Keli5，STC-ISP</p><h2 id="单片机和开发板简介"><a href="#单片机和开发板简介" class="headerlink" title="单片机和开发板简介"></a>单片机和开发板简介</h2><p>单片机，检测MCU，内部集成CPU、RAM、ROM、定时器等一系列电脑常用硬件</p><p>单片机的任务是信息采集、处理、硬件设备</p><p>单片机和计算机相比体积小但是性能较差，成本低结构简单</p><p>unsigned int：无符号int（16位）型数据（单片机内int是默认有单位的）<br>同理：unsigned short、unsigned long……</p><p>祝：非整型除了unsigned char（8位十六进制数）不能加unsigned前缀表示无符号，unsigned和后面有空格</p><h2 id="LCD1602调试工具"><a href="#LCD1602调试工具" class="headerlink" title="LCD1602调试工具"></a>LCD1602调试工具</h2><p>使用LCD1602液晶屏作为调试窗口</p><p>使用液晶屏的时候数码管和LED模块因为引脚占用无法使用</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">LCD_Init()</td><td align="center">初始化</td><td align="center">无</td></tr><tr><td align="center">LCD_ShowChar(1,1,’A’)</td><td align="center">显示一个字符</td><td align="center">行，列，现实的字符</td></tr><tr><td align="center">LCD_ShowString(1,3,”Hello”)</td><td align="center">显示字符串</td><td align="center">行，起始列，字符串</td></tr><tr><td align="center">LCD_ShowNum(1,9,123,3)</td><td align="center">显示十进制数字</td><td align="center">行，起始列，数字，数字长度（范围1-5）</td></tr><tr><td align="center">LCD_ShowSignedNum(2,1,-66，2)</td><td align="center">显示有符号十进制数字</td><td align="center">同上</td></tr><tr><td align="center">LCD_ShowHexNum(2,1,0xA8,2)</td><td align="center">显示十六进制数字</td><td align="center">同上</td></tr><tr><td align="center">LCD_ShowBinNum(2,4,0xAA,8)</td><td align="center">显示二进制数字</td><td align="center">行，起始列，数字（只能用十六进制数字代替），长度</td></tr></tbody></table><h2 id="51单片机矩阵键盘"><a href="#51单片机矩阵键盘" class="headerlink" title="51单片机矩阵键盘"></a>51单片机矩阵键盘</h2><p>51单片机中矩阵键盘接在STC89C52RC的10-17脚，我们可以通过逐列扫描的方法来完成对按键是否被按下进行确定，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsigned char Matrixkey()<br>&#123;<br>unsigned char KeyNumber=0;<br><br>// ????<br>P1=0xFF;<br>P1_3=0;<br>if(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=1;&#125;<br>if(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=5;&#125;<br>if(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=9;&#125;<br>if(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=13;&#125;<br><br>P1=0xFF;<br>P1_2=0;<br>if(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=2;&#125;<br>if(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=6;&#125;<br>if(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=10;&#125;<br>if(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=14;&#125;<br><br>P1=0xFF;<br>P1_1=0;<br>if(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=3;&#125;<br>if(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=7;&#125;<br>if(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=11;&#125;<br>if(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=15;&#125;<br><br>P1=0xFF;<br>P1_0=0;<br>if(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=4;&#125;<br>if(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=8;&#125;<br>if(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=12;&#125;<br>if(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=16;&#125;<br><br>return KeyNumber;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们声明了一个扫描的函数，在你按下后松开之前函数不会继续进行但是手松开之后会返回你按下按键对应的数值。</p><p>利用这个键盘我们可以完成一些简单的功能，比如说下面的代码利用矩阵键盘完成了一个简单的个位数计算器（Matrixkey（）函数在Matrixkey头文件中定义了）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">#include &lt;REGX52.H&gt;<br>#include &quot;Matrixkey.h&quot;<br>#include &quot;Delay.h&quot;<br>#include &quot;LCD1602.h&quot;<br>int Num1 = 0, Num2 = 0, Num3 = 0;<br>int Answer = 0;<br>unsigned char b;<br>void main()<br>&#123;<br>    LCD_Init();<br>    while (1)<br>    &#123;<br>        LCD_ShowString(1, 1, &quot;Input equations&quot;);<br>        while (Num1 &gt;= 10 || Num1 == 0)<br>        &#123;<br>            Num1 = Matrixkey();<br>        &#125;<br>        LCD_ShowNum(2, 1, Num1, 1);<br><br>        while (Num2 &gt;= 14 || Num2 &lt;= 9)<br>        &#123;<br>            Num2 = Matrixkey();<br>        &#125;<br>        if (Num2 == 10)<br>        &#123;<br>            b = &#x27;+&#x27;;<br>            LCD_ShowString(2, 2, &quot;+&quot;);<br>        &#125;<br>        else if (Num2 == 11)<br>        &#123;<br>            b = &#x27;-&#x27;;<br>            LCD_ShowString(2, 2, &quot;-&quot;);<br>        &#125;<br>        else if (Num2 == 12)<br>        &#123;<br>            b = &#x27;*&#x27;;<br>            LCD_ShowString(2, 2, &quot;*&quot;);<br>        &#125;<br>        else if (Num2 == 13)<br>        &#123;<br>            b = &#x27;/&#x27;;<br>            LCD_ShowString(2, 2, &quot;/&quot;);<br>        &#125;<br><br>        while (Num3 &gt;= 10 || Num3 == 0)<br>        &#123;<br>            Num3 = Matrixkey();<br>        &#125;<br>        LCD_ShowNum(2, 3, Num3, 1);<br><br>        if (b == &#x27;+&#x27;)<br>        &#123;<br>            Answer = Num1 + Num3;<br>        &#125;<br>        else if (b == &#x27;-&#x27;)<br>        &#123;<br>            Answer = Num1 - Num3;<br>        &#125;<br>        else if (b == &#x27;*&#x27;)<br>        &#123;<br>            Answer = Num1 * Num3;<br>        &#125;<br>        else if (b == &#x27;/&#x27;)<br>        &#123;<br>            Answer = Num1 / Num3;<br>        &#125;<br>LCD_ShowString(2,4,&quot;=&quot;);<br>if(Answer&lt;0)<br>&#123;<br>Answer=-Answer;<br>LCD_ShowString(2,5,&quot;-&quot;);<br>LCD_ShowNum(2, 6, Answer, 2);<br>&#125;else<br>&#123;<br>LCD_ShowSignedNum(2, 5, Answer, 2);<br>&#125;<br>        <br><br>        Num1 = Num2 = Num3 = 0;<br>        Delay(1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>蜂鸣器分为有源蜂鸣器和无源蜂鸣器，其中的“源”指的是震荡源<br>有源蜂鸣器只要通电就可以发声，但是振荡频率固定<br>无源蜂鸣器内部不带振荡源，需要提供振荡脉冲的频率，但是发声频率可以调整</p><p>正负极看标志或者长短脚（长脚为正极）</p><h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>TXD &#x3D; transmit exchange data<br>RXD &#x3D; receive ~ ~<br>TXD和RXD要交叉连接，VCC和GND对接</p><p>只需单项数据传输时，可以只连接一根通信线</p><p>当电平标准不一致时，需要加电平转换芯片</p><blockquote><p>电平标准是与数据对应关系1和0的表达方式，是传输线缆中人为规定的电压，常用的有以下三种<br>TTL电平：+5V表示1，0V表示0；<br>RS232电平：-3——-5V表示1，+3——+15V表示0<br>RS485电平：两线压差+2——+6V表示1，-2——-6V表示0（差分信号）’<br>前两者距离短，容忍电压大，常用于电脑等，后者距离远可达1km</p></blockquote><p>相关术语：<br>· 全双工 ： 通信双方可以在同一时刻相互传输数据<br>· 半双工 ： 通信双方可以相互传输数据，但是必须分时复用一根数据线<br>· 单工 ： 通信只能由一方发送到另一方，不能反向传输</p><p>· 异步 ： 通信双方各自约定通信速率<br>· 同步 ： 通信双方靠一根时钟线来约定通信速率</p><p>· 总线：连接各个设备的数据的传输线路</p><p>· 波特率：串口通信的速率（发送和接受各数据位ied间隔时间）</p><p>—目前已学习完毕，暂时不考虑继续更新—</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;51单片机学习笔记&quot;&gt;&lt;a href=&quot;#51单片机学习笔记&quot; class=&quot;headerlink&quot; title=&quot;51单片机学习笔记&quot;&gt;&lt;/a&gt;51单片机学习笔记&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="STC" scheme="http://passengerdong.github.io/tags/STC/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="嵌入式" scheme="http://passengerdong.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Arduino学习日志</title>
    <link href="http://passengerdong.github.io/2023/11/22/arduino%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>http://passengerdong.github.io/2023/11/22/arduino%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2023-11-22T08:45:08.000Z</published>
    <updated>2024-11-18T15:57:26.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arduino学习日志"><a href="#Arduino学习日志" class="headerlink" title="Arduino学习日志"></a>Arduino学习日志</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是我个人在Arduino学习上所做的笔记，arduino的学习是为了未来32单片机以及51单片机的学习作提前适应</p><p>由于受限于图片上传我仅会在这篇笔记展示代码的内容，硬件部分我会尝试在一些其他的平台展示（也许会做一个微信公众号）</p><p><strong>叠甲：这篇文章可能存在一些错误，如果您发现了，请在评论区为我留言，我将很快改正</strong></p><h2 id="部分省略"><a href="#部分省略" class="headerlink" title="部分省略"></a>部分省略</h2><p>由于arduino的一些语法是和C&#x2F;C++有相似之处，所以语法基础这篇笔记掠过不踢</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>串口通讯是传输数据的一种方式，所有arduino控制器都有至少一个串行端口（UART）。串口通讯主要由RX（receice接受）、TX（transport发送）、GND（ground接地）三个接口组成，控制器可以据此与其他单片机、传感器、计算机进行通讯</p><p>个人计算机可以使用USB接口与arduino的引脚0（RX）和引脚1（TX）进行串口通讯</p><p>优点：·发展时间长，技能成熟可靠<br>     ·兼容性好、很多电子设备支持串口<br>     ·使用方便，实现简单</p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>Serial.begin(speed)：初始化串口数据，打开串口通讯，并设置传输速率<br>    · 参数 spped：波特率,<strong>设定的波特率需要和IDE上的波特率相同，否则会出错</strong></p><p>Serial.available()：用于检测控制器是否接到数据。返回值为等待读取的数据字节</p><p>Serial.print(val,format)：串口输函数，发送ASCII码型数据，被发送的数据可以使任何格式<br>    ·参数 format：可为BIN（二进制）DEC（十进制）HEX（十六进制）OCT（八进制）<br>例：Serial.print(“Passenger”)-&gt;输出Passenger<br>    Serial.print(23,BIN)-&gt;输出：0001 1001</p><p>Serial.println(val,format)：在Serial.print()的基础上换个行</p><p>Serial.write(val)：串口输出函数，发送单个字节或字符串<br>    · val&#x3D;65时输出A（val为数字时会根据ASCII码发送字符）</p><p>Serial.read()：串口读取函数，每次读取一个字节<br>    · 没收到时返回-1<br>    · 收到时返回值为接收到的数据流中的一个字符</p><p>Serial.parselnt()：串口数据解析函数，用来读取所接收到的数据中的整数，从数据中第一个数字读取到连续的最后一个数字。可以重复使用。</p><pre><code>parselnt()读取数据时，会忽略字母并提取数字，每次读取后，数字之前的数据和数字本身会从缓存区删除，其他数据保持不变</code></pre><p>Serial.parseFloat()：串口数据解析函数，用来读取数据中的小数。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arduino学习日志&quot;&gt;&lt;a href=&quot;#Arduino学习日志&quot; class=&quot;headerlink&quot; title=&quot;Arduino学习日志&quot;&gt;&lt;/a&gt;Arduino学习日志&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="嵌入式" scheme="http://passengerdong.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习日志</title>
    <link href="http://passengerdong.github.io/2023/11/10/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>http://passengerdong.github.io/2023/11/10/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2023-11-10T08:02:34.000Z</published>
    <updated>2024-11-18T15:33:13.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux是一个免费、开源、可靠、安全、稳定、多平台的操作系统内核，这篇文章将随着我的学习进程不断更新用于作为笔记。</p><hr><h2 id="一些小知识（"><a href="#一些小知识（" class="headerlink" title="一些小知识（"></a>一些小知识（</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>· Ctrl+L：清空终端</p><h3 id="小知识（没啥用也许"><a href="#小知识（没啥用也许" class="headerlink" title="小知识（没啥用也许"></a>小知识（没啥用也许</h3><p>· 使用ls查看目录下内容时，深色的为文件夹，浅色的为文件；<br>使用ls -l时，最前面为d（directory）的是文件夹，为-的是文件</p><p>· 使用<code>su -root</code>然后输入用户密码，获得最大权限（切换root用户）</p><h4 id="通配符“-”"><a href="#通配符“-”" class="headerlink" title="通配符“*”"></a>通配符“*”</h4><p>通配符“*”，用来做模糊匹配</p><p>通配符，即匹配任意内容（包括空），例：<br>· test* 表示匹配任何以test开头的内容<br>· *test 表示匹配任何以test结尾的内容<br>· <em>test</em> 表示任何包含test的内容</p><h4 id="管道符“-”"><a href="#管道符“-”" class="headerlink" title="管道符“|”"></a>管道符“|”</h4><p>管道符“|”，把管道符左侧输出的结果作为右边的输入</p><p>左侧可以是任何有输出的命令，右侧只能是有<strong>可作为内容输入端口</strong>参数的命令</p><p>例：<code>cat test.txt | grep pessenger</code></p><p>原本上面grep命令应该为<code>grep pessenger 筛选内容</code>，但是grep命令的筛选内容参数可作为<strong>内容输入端口</strong>，所以在使用管道符时可以省略，将管道符之前内容作为参数输入</p><p>注：管道符可以嵌套使用，比如：<code>cat test.txt | grep pessenger | grep D</code></p><p>即：<code>cat test.txt</code>的输出（输出内容1）作为参数进行<code>grep pessenger 输出内容1</code>,得到输出内容2，在输入输出内容2进行命令<code>grep D 输出内容2</code>得出最后我们看到的输出内容</p><h4 id="反引号“-”（又称飘号）"><a href="#反引号“-”（又称飘号）" class="headerlink" title="反引号“&#96;”（又称飘号）"></a>反引号“&#96;”（又称飘号）</h4><p>用反引号包围的命令不会被作为参数，而是将命令输出的内容作为参数输入</p><p>例：<code>echo pwd</code>输出结果为pwd，而<code>echo &quot;pwd&quot;</code>输出内容是当前目录位置</p><h4 id="重定向符“-”和“-”"><a href="#重定向符“-”和“-”" class="headerlink" title="重定向符“&gt;”和“&gt;&gt;”"></a>重定向符“&gt;”和“&gt;&gt;”</h4><h5 id=""><a href="#" class="headerlink" title="&gt;"></a>&gt;</h5><p>将左侧命令的结果<strong>覆盖</strong>写入到符号右侧指定的文件中</p><p>例：<code>eacho &quot;Hello Linux&quot; &gt; test.txt</code>-&gt;test.txt内容为“Hello Linux”</p><h5 id="-1"><a href="#-1" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h5><p>将左侧命令的结果<strong>追加</strong>写入到符号右侧的指定文件中</p><p>例：<code>echo &quot;Hello Linux&quot; &gt;&gt; test.txt</code>-&gt;test.txt最后多一行“Hello Linux”</p><hr><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><h3 id="命令结构"><a href="#命令结构" class="headerlink" title="命令结构"></a>命令结构</h3><p>Linux的命令结构大致为：<code>[commend] [-option] [parameter]</code></p><p>其中：<br>· commend 指的是命令本身，比如：ls、cd等<br>· -option 指的是命令的一些选项，可以通过这个来选择控制命令的行为细节<br>· parameter 指的是命令的参数，用于命令的指向目标</p><p><strong>注：<code>[-0ption]</code>和<code>[parameter]</code>是可选的而不是必须的</strong></p><h2 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>ls命令的作用是列出目录下的内容，细节如下：</p><p><code>ls [-a -l -h] [Linux路径]</code></p><p><strong>前置小知识</strong>：<br>·Home目录：每一个用户在Linux系统的专属目录默认在<code>:/home/用户名</code><br>·当前工作目录： Linux在执行命令的时候往往需要一个工作目录来打开命令程序（终端），默认设置工作目录在用户的home目录</p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><h5 id="a选项"><a href="#a选项" class="headerlink" title="-a选项"></a>-a选项</h5><p><code>-a</code>选项 表示“all”，即列出所有文件（包括隐藏的）</p><p>显示的文件里面开头是 <strong>“.”</strong> 的就是隐藏的文件</p><h5 id="l选择"><a href="#l选择" class="headerlink" title="-l选择"></a>-l选择</h5><p><code>-l</code>选项 以纵向的形式展示内容，并展示更多内容</p><h5 id="h选择"><a href="#h选择" class="headerlink" title="-h选择"></a>-h选择</h5><p><code>-h</code>选项 可以更好的展示内存，但是只能和 <code>-l</code> 一起使用</p><h5 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h5><p>可以选择分别使用选项，比如 <code>ls -l -a -h</code>，也可以组合使用，比如<code>ls -lah</code>两者等效并且前后顺序没有影响。</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd命令就是更改工作目录，语法是：</p><p><code>cd [Linux路径]</code></p><p><strong>注：cd没有选项只有路径</strong></p><p>cd直接执行不写参数就是回到根目录</p><h4 id="绝对路径和相对路劲"><a href="#绝对路径和相对路劲" class="headerlink" title="绝对路径和相对路劲"></a>绝对路径和相对路劲</h4><p><strong>绝对路径</strong>即从根目录为起点，以 <strong>&#x2F;</strong> 开头</p><p><strong>相对路径</strong>从当前文件夹开始，不需要&#x2F;开头</p><h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><p>·**.** 表示当前目录     例：<code>cd ./desktop</code>就是切换到当前目录下的desktop目录内</p><p>·**..**表示上一级目录     例：<code>cd ../.. </code> 切换到上二级目录</p><p>·**~**表示HOME目录     例：<code>cd ~/desktop</code>切换到根目录的desktop目录</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>（Print Work Directory） 用于查看当前所在的工作目录</p><p>pwd<strong>没有选项</strong>，并且<strong>没有参数</strong>，直接执行即可</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>mkdir命令（来自“Make Directory”）可以创建新的目录（文件夹）</p><p>语法：<code>mkdir [-p] Linux路径</code></p><p>注：·参数必填，相对路径以及绝对路径均可<br>    · -p选项可选，表示创建不存在父目录，适用于连续多级的目录<br>    · 创建文件夹需要修改权限，在home目录内可以直接创建，在home目录之外需要权限</p><p>例：<code>mkdir pessenger</code>，<code>mkdir ./pessenger</code>等</p><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><h5 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h5><p>-p 可以没有父目录的目录，用于创建连续目录</p><p>例： <code>mkdir -p /pessenger/hello/world</code></p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>用来创建文件，语法：<code>touch Linux路径</code> </p><p>注：touch命令<strong>没有选项</strong>，但是<strong>参数必填</strong></p><p>例：<code>touch text.txt</code> </p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件内容,语法：<code>cat Linux路径</code></p><p>注：cat命令也没有路径且参数必填</p><p>例：<code>cat test.txt</code></p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>也可以查看文件内容，语法：<code>more Linux路径</code></p><p>注：more也没有选项且参数必填</p><h4 id="文件内操作"><a href="#文件内操作" class="headerlink" title="文件内操作"></a>文件内操作</h4><p>·space键：下一页<br>·ENTER键：：下一行<br>·B键上一页<br>·Q键退出</p><h4 id="more与cat的区别"><a href="#more与cat的区别" class="headerlink" title="more与cat的区别"></a>more与cat的区别</h4><p>·cat直接将内容全部展示出来<br>·more支持翻页，若文件内容过多，可以一页页展示</p><p>所以more较cat更适合大文件的查看</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件&#x2F;文件夹（copy），语法：<code>cp [-r] 参数1 参数2</code></p><p>参数1：Linux路径，表示被复制的文件或者文件夹</p><p>参数2：Linux路径，表示要复制去的文件或者文件夹</p><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><h5 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h5><p>用于复制文件夹用，表示递归</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>用于移动文件夹&#x2F;文件（move），语法：<code> mv 参数1 参数2</code></p><p>参数1：Linux路径，表示被移动的文件或者文件夹</p><p>参数2：Linux路径，表示要移动到的地方（若目标不存在则改名确保存在）</p><p>例：若目标存在，比如：<code>mv text.txt /desktop</code>，text.txt就被移动到了desktop目录下<br>    若目录不存在，比如：<code>mv text.txt text2.txt</code>(text1.txt不存在这个目录下)，text.txt就被重命名成了text1.txt</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>用于删除文件&#x2F;文件夹（来自remove），语法：<code>rm [-r -f] 参数1 参数2 …… 参数n</code></p><p>参数为要删除的文件或者文件夹路径</p><p><strong>谨慎使用rm命令，尤其root用户时</strong><br><code>rm -rf/</code>,<code>rm -rf/*</code>等效于电脑格式化（删光光）</p><h4 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h4><h5 id="r-1"><a href="#r-1" class="headerlink" title="-r"></a>-r</h5><p>同cp命令，用于删除文件夹</p><h5 id="f"><a href="#f" class="headerlink" title="-f"></a>-f</h5><p>-f表示force，强制删除（不会弹出确认信息）</p><p>注：<br> ·普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示<br> ·一般用户不使用-f选项</p><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>我们前面学的Linux命令，本体就是一个个二进制的可执行程序（相当于windows的exe文件）</p><p>which命令查看一系列命令的程序文件存放在哪里，语法：<code>which Linux命令</code></p><p>例：<code>which cd</code></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>搜索指定的文件，语法：<code>find 起始路径 -name &quot;被查找文件名&quot;</code>（以文件名查找）<br>                    <code>find 起始路径 -size +/-n[kMG]</code>(以 大小查找文件)</p><p>+、-表示大于小于；n表示大小数字；[]内为大小单位（k为kb，M为MB，G为GB）</p><p>注：允许使用通配符</p><p>例：<code>find /desktop &quot;-name&quot; *text</code>，<code>find -size +1k</code></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>从文件中，通过关键字过滤文件行，语法：<code>grep [-n] 关键词 文件路径</code></p><p>选项-n（可选）：表示在结果中显示匹配行的行号</p><p>参数·关键字（必填）：表示过滤的关键字，带有space或者其他特殊符号时建议用””把关键字包起来（建议一直使用“”包围）</p><p>参数·文件路径（必填）：表示要过滤的文件的路径，<strong>可作为内容输入端口</strong></p><p>例：<code>grep &quot;pessenger&quot; text.txt</code></p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>文件内容统计，包括行数，单词数量等，语法：<code>wc [-c -m -l -w] 文件路径</code></p><p>参数文件路径（必填），被统计路径，<strong>可作为内容输入端口</strong></p><p>例：<code>wc -c test.txt</code></p><h4 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h4><h5 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h5><p>统计bytes数量</p><h5 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h5><p>统计字符数量</p><h5 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h5><p>统计字数</p><h5 id="w"><a href="#w" class="headerlink" title="-w"></a>-w</h5><p>统计单词数量</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>在命令行内输出指定内容，语法：<code>echo 输出内容</code></p><p>注：无选项，参数较复杂时可用“”包围</p><p>例：<code>echo &quot;Hello Linux&quot;</code></p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>可以查看文件尾部内容，跟踪文件最新更改，语法：<code>tail [-f -num] Linux路径</code></p><p>·参数Linux路径：表示被追踪的文件路径</p><p>例：<code>tail test.txt</code></p><h4 id="选项-5"><a href="#选项-5" class="headerlink" title="选项"></a>选项</h4><h5 id="f-1"><a href="#f-1" class="headerlink" title="-f"></a>-f</h5><p>表示持续追踪，例：<code>tail -f test.txt</code>（运行之后不会主动停止并一直更新用户在对参数对象操作之后的结果）</p><p>注：<strong>CTRL+C</strong>强制停止运行</p><h5 id="num"><a href="#num" class="headerlink" title="-num"></a>-num</h5><p>表示查看尾部多少行，num为具体数字，不填<strong>默认10行</strong>，例：<code>tail -5 test.txt</code></p><hr><h2 id="Vim-Vi-编辑器"><a href="#Vim-Vi-编辑器" class="headerlink" title="Vim&#x2F;Vi 编辑器"></a>Vim&#x2F;Vi 编辑器</h2><p>Vi&#x2F;Vim是Linux最经典的文本编辑器（Vim是Vi的加强版）</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>此模式下，所敲的按键编辑器都会理解为命令，用命令驱动不同功能。</p><p>此模式下不能自由进行文本编辑</p><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>编辑模式、插入模式</p><p>此模式下，可以自由地对文件内容进行编辑</p><h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p>以”:”开始，通常用于文件的保存退出</p><p>打开编辑器时默认是<strong>命令模式</strong></p><p>*注：你<strong>可以</strong>从命令模式进入输入模式和底线命令模式，但是<strong>不可以</strong>从输入模式进入底线模式或相反，只能从两者回到命令模式再进入另一方</p><p><strong>用打开vi&#x2F;vim打开并编辑文件</strong></p><p><code>vi/vim 文件路径</code></p><p>如果存在文件就打开，如果不存在就新建一个文件，再打开进行编辑</p><h4 id="命令模式的命令（缩写）表"><a href="#命令模式的命令（缩写）表" class="headerlink" title="命令模式的命令（缩写）表"></a>命令模式的命令（缩写）表</h4><table><thead><tr><th align="center">模式</th><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">命令模式</td><td align="center">i</td><td align="center">在当前光标位置进入<strong>输入模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">a</td><td align="center">在当前光标位置<strong>之后</strong>进入<strong>输入模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">I</td><td align="center">在当前行的开头进入<strong>输入模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">A</td><td align="center">在当前行的结尾进入<strong>输入模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">o</td><td align="center">在当前光标的上一行进入<strong>输入模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">O</td><td align="center">在当前光标的下一行进入<strong>输入模式</strong></td></tr><tr><td align="center">输入模式</td><td align="center">esc</td><td align="center">任何情况下输入esc都能回到<strong>命令模式</strong></td></tr><tr><td align="center">命令模式</td><td align="center">↑、k</td><td align="center">向上移动光标</td></tr><tr><td align="center">命令模式</td><td align="center">↓、j</td><td align="center">向下移动光标</td></tr><tr><td align="center">命令模式</td><td align="center">←，h</td><td align="center">向左移动光标</td></tr><tr><td align="center">命令模式</td><td align="center">→、l</td><td align="center">向右移动光标</td></tr><tr><td align="center">命令模式</td><td align="center">0</td><td align="center">移动光标到当前行的开头</td></tr><tr><td align="center">命令模式</td><td align="center">$</td><td align="center">移动光标到当前行的结尾</td></tr><tr><td align="center">命令模式</td><td align="center">pageup（PgUp）</td><td align="center">向上翻页</td></tr><tr><td align="center">命令模式</td><td align="center">pagedown（PgDn）</td><td align="center">向下翻页</td></tr><tr><td align="center">命令模式</td><td align="center">&#x2F;</td><td align="center">进入搜索模式</td></tr><tr><td align="center">命令模式</td><td align="center">n</td><td align="center">向下继续搜索</td></tr><tr><td align="center">命令模式</td><td align="center">N</td><td align="center">向上继续搜索</td></tr><tr><td align="center">命令模式</td><td align="center">dd</td><td align="center">删除光标所在行的内容</td></tr><tr><td align="center">命令模式</td><td align="center">ndd</td><td align="center">n是数字，表示删除当前光标向下n行</td></tr><tr><td align="center">命令模式</td><td align="center">yy</td><td align="center">复制当前行</td></tr><tr><td align="center">命令模式</td><td align="center">nyy</td><td align="center">n位为数字，表示复制当前光标向下n行</td></tr><tr><td align="center">命令模式</td><td align="center">p</td><td align="center">黏贴复制的内容</td></tr><tr><td align="center">命令模式</td><td align="center">u</td><td align="center">撤销修改</td></tr><tr><td align="center">命令模式</td><td align="center">CTRL+r</td><td align="center">反向撤销修改</td></tr><tr><td align="center">命令模式</td><td align="center">gg</td><td align="center">回到首行</td></tr><tr><td align="center">命令模式</td><td align="center">G</td><td align="center">跳到行尾</td></tr><tr><td align="center">命令模式</td><td align="center">dG</td><td align="center">从当前行开始删除下面所有内容</td></tr><tr><td align="center">命令模式</td><td align="center">dgg</td><td align="center">从当前行开始删除上面所有内容</td></tr><tr><td align="center">命令模式</td><td align="center">dS</td><td align="center">从当前光标开始删除到本行结尾</td></tr><tr><td align="center">命令模式</td><td align="center">dG</td><td align="center">从当前光标开始删除到本行开头</td></tr><tr><td align="center">命令模式</td><td align="center">:</td><td align="center">进入底线命令模式</td></tr><tr><td align="center">底线命令模式</td><td align="center">:wq</td><td align="center">保存并退出</td></tr><tr><td align="center">底线命令模式</td><td align="center">:q</td><td align="center">仅退出</td></tr><tr><td align="center">底线命令模式</td><td align="center">:q!</td><td align="center">强制退出</td></tr><tr><td align="center">底线命令模式</td><td align="center">:w</td><td align="center">仅保存</td></tr><tr><td align="center">底线命令模式</td><td align="center">:set nu</td><td align="center">显示行号</td></tr><tr><td align="center">底线命令模式</td><td align="center">:set paste</td><td align="center">设置黏贴模式（用于从外部复制内容，防止格式错乱）</td></tr></tbody></table><hr><h2 id="root及相关"><a href="#root及相关" class="headerlink" title="root及相关"></a>root及相关</h2><p>root用户，即超级用户，是拥有最大权限的账户</p><p>root用户拥有一般用户没有的权限，例如：在根目录创建文件夹等</p><p>普通用户的权限一般在HOME目录内是不受限的，一旦出了HOME目录，一般用户在大部分地方只有只读和执行权限，无修改权限</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>我们可用使用<code>su</code>命令来切换用户（switch user）</p><p>语法：<code>su [-] [用户名]</code></p><p>注：<br>·“-”符号是可选的，表示是否加载环境变量，建议带上。<br>·参数：用户名，表示要切换的用户，可省略，省略表示切换到root<br>·切换用户后可用<code>exit</code>命令退回到上一个用户，也可以使用快捷键<strong>CTRL+D</strong></p><p>·普通用户切换到其他用户<strong>需要输入密码</strong><br>·root用户切换到其他用户<strong>不需要密码</strong></p><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>长期使用root用户可能会对系统产生损坏，所以可以使用sudo来为普通命令授权，临时以root身份执行</p><p>语法：<code>sudo 其他命令</code></p><p>在其他命令前带上sudo即可为这一条命令临时赋予root授权</p><p>注：不是所有用户都有权利使用sudo，我们<strong>需要为普通用户配置sudo认证</strong></p><h4 id="为普通用户配置sudo认证"><a href="#为普通用户配置sudo认证" class="headerlink" title="为普通用户配置sudo认证"></a>为普通用户配置sudo认证</h4><p>1.切换到root用户，执行<code>visudo</code>命令，会通过vi打开：&#x2F;etc&#x2F;sudoers</p><p>2.在文件最后添加：<br><code>用户名 ALL=(ALL)         NOPASSSWD:ALL</code><br>其中：NOPASSSWD：ALL表示使用sudo命令无需输入密码</p><p>3.使用wq保存</p><p>4.换回普通用户即可使用</p><h2 id="用户以及用户组"><a href="#用户以及用户组" class="headerlink" title="用户以及用户组"></a>用户以及用户组</h2><p>在Linux中可以：<br>· 配置多个用户<br>· 配置多个用户组<br>· 用户可以加入到多个用户组中</p><p>linux系统中关于权限的管控级别有两个：</p><ul><li>针对用户的权限控制</li><li>针对用户组的权限控制</li></ul><h3 id="用户组及用户管理命令"><a href="#用户组及用户管理命令" class="headerlink" title="用户组及用户管理命令"></a>用户组及用户管理命令</h3><p><strong>用户组以及用户相关命令只有root用户才可以执行</strong></p><h4 id="用户组相关命令"><a href="#用户组相关命令" class="headerlink" title="用户组相关命令"></a>用户组相关命令</h4><p>创建用户组：<code>groupadd 用户组名称</code></p><p>删除用户组：<code>groupdel 用户组名称</code></p><h4 id="用户相关命令"><a href="#用户相关命令" class="headerlink" title="用户相关命令"></a>用户相关命令</h4><p>创建用户：<code>useradd [-g 用户组 -d home目录] 用户名</code><br>    ·选项-g：指定用户组，若不指定则创建一个与用户同名的用户组然后把这个用户塞进去（-g指定的组需要已存在，如果已存在同名的用户组，必须使用-g）<br>    ·选项-d：指定用户的HOME目录，不指定就默认在：&#x2F;home&#x2F;用户名</p><p>删除用户：<code>userdel [-r] 用户名</code><br>    ·选项-r：删除用户的home目录，如果不带则不删除</p><p>产看用户所属组：<code>id [用户名]</code><br>    ·参数用户名：被查看的用户，不带就看自己</p><p>修改用户所属组：<code>user mod -aG 用户组 用户名</code><br>将指定用户移动到指定用户组</p><h4 id="getent命令：查看当前系统有哪些用户和用户组"><a href="#getent命令：查看当前系统有哪些用户和用户组" class="headerlink" title="getent命令：查看当前系统有哪些用户和用户组"></a>getent命令：查看当前系统有哪些用户和用户组</h4><p>语法1：<code>getent password</code>（password是你的密码）</p><p>每条结果包括七份信息，分别是：<br>    用户名：密码（x）：用户ID：组ID：描述信息（没啥软用）：HOME目录：执行终端（默认bash）</p><p>语法2：<code>getent group</code></p><p>每条结果包含三份信息，分别是：<br>    组名称：组认证（显示为x）：组ID</p><h2 id="查看权限控制"><a href="#查看权限控制" class="headerlink" title="查看权限控制"></a>查看权限控制</h2><h3 id="认知权限信息"><a href="#认知权限信息" class="headerlink" title="认知权限信息"></a>认知权限信息</h3><p>当你使用<code>ls -l</code>命令查看内容时，会显示权限细节。</p><p>以一条结果为例：<br>    <code>drwxr-xr-x. 3 pessenger passenger 4 11月   4 5:14 Desktop</code><br>        <strong>1</strong>       <strong>2</strong>     <strong>3</strong><br>其中：第一部分表示文件、文件夹的权限控制信息<br>      第二部分表示文件、文件夹所属用户<br>      第三部分：表示文件、文件夹所属用户组</p><p>第一部分用于展示文件、文件夹的具体权限，可以分为十个槽位：<br><code>-/d/l</code> <code>r/-</code> <code>w/-</code> <code>x/-</code> <code>r/-</code> <code>w/-</code> <code>x/-</code> <code>r/-</code> <code>w/-</code> <code>x/-</code></p><p>· 第一块：-表示文件<br>         d表示文件夹<br>         l表示软链接<br>· 第2-4块表示所属用户权限</p><p>· 第5-7块表示所属用户组的权限</p><p>· 第8-10块表示其他用户权限</p><p>r 表示读权限<br>w 表示写权限<br>x 表示执行权限</p><p><strong>对于文件、文件夹的不同，rwx的含义有细微差别</strong>：<br>· r 针对文件可以查看文件内容<br>    针对文件夹可以查看文件夹内容（如ls命令）<br>· w 针对文件可以修改文件内容<br>    针对文件夹可以在文件夹内创建、删除、修改等操作<br>· x 针对文件可表示将文件作为程序执行<br>    针对文件夹可表示更改工作目录到这个文件夹，即cd进入</p><h3 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h3><p>chomd命令用于修改文件、文件夹的权限信息</p><p><strong>注：只有文件、文件夹的所属用户或者root用户才可修改</strong></p><p>语法：<code>chmod [-R] 权限 文件/文件夹</code><br>· -R 对文件夹内所有内容应用同样操作</p><p>例：<code>chmod u=rwx,g=rx,o=x hello.txt</code>将文件权限修改为rwxr-x–x<br>    ·其中：u表示user所属用户权限，g表示group组权限，o表示other其他权限</p><p>chmod语法也可以简化，例如：<code>chmod 761 hello.txt</code></p><p>这句命令相当于<code>chmod u=rwx,g=rw,o=x hello.txt</code></p><p>例句中的7、6、1分别将u、g、o的权限修改</p><p>我们可以把三位上的每个数字分别理解为一个三位二进制数</p><p>比如<code>7</code>就相当于<code>111</code>即rwx三个权限都有；<code>6</code>相当于<code>110</code>即拥有rw两个权限</p><p>用这种表达可以更加快速便捷地执行chmod命令</p><h3 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h3><p>chown命令可以修改文件文件夹的所属用户和所属用户组</p><p><strong>注：普通用户无法修改所属为其他用户或族，此命令仅适用于root用户执行</strong></p><p>语法：<code>chown [-R] [用户] [:] [用户组] [文件或者文件夹]</code><br>    · 选项-R：同chmod<br>    · 选项用户：修改所属用户<br>    · 选项用户组：修改所属用户组<br>    · “:”：用于分隔用户和用户组</p><p>例：<code>chown root hello.txt</code> 将hello.txt所属用户组修改为root<br>    <code>chown root:pessenger hello.txt</code>将hello.txt所属用户改为root，用户组改为pessenger</p><h2 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h2><p>用于练习，锻炼熟练度。本环节不会有较多的文字，只是作为实战过程中部分须注意点的记录。</p><h3 id="在Linux上部署各类软件"><a href="#在Linux上部署各类软件" class="headerlink" title="在Linux上部署各类软件"></a>在Linux上部署各类软件</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Linux是一个免费、开源、可靠、安全、稳定、多平台的操作系统内核，这篇文章将随着我的学习进程不断更新用于作为笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;h</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    <category term="note" scheme="http://passengerdong.github.io/categories/note/"/>
    
    
    <category term="note" scheme="http://passengerdong.github.io/tags/note/"/>
    
    <category term="linux" scheme="http://passengerdong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="http://passengerdong.github.io/2023/10/28/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://passengerdong.github.io/2023/10/28/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-10-28T07:22:32.000Z</published>
    <updated>2024-11-18T15:32:42.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0基础使用hexo搭建个人博客"><a href="#0基础使用hexo搭建个人博客" class="headerlink" title="0基础使用hexo搭建个人博客"></a>0基础使用hexo搭建个人博客</h1><h2 id="先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。"><a href="#先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。" class="headerlink" title="先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。"></a>先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。</h2><p>hexo是一个简洁高效的博客框架，利用hexo将服务器布局在github上可以做到零成本的个人博客搭建</p><p>以下是大体的步骤</p><p>1.前期准备</p><p>2.hexo本地部署与上传</p><p>3.个性化</p><p>· 由于我个人是Windows系统，下列的操作我将以Windows系统为例，mac✌的操作步骤也是大致相同的，可以简单的代替一下部分语句进行操作。</p><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h3><h5 id="首先我们需要创建一个GitHub账户"><a href="#首先我们需要创建一个GitHub账户" class="headerlink" title="首先我们需要创建一个GitHub账户"></a>首先我们需要创建一个GitHub账户</h5><p>国内也有一些可以代替的网站比如<a href="https://gitee.com/">Gitee</a>等，但是没几个可以和GitHub比的，所以原则上我们最推荐GitHub</p><p><a href="https://github.com/">Github官网</a></p><p>部分用户在打开GitHub时会有一些困难，可以耐心等待（或者开个魔法，也许有帮助？）</p><p>具体步骤可以看这里<a href="https://blog.csdn.net/m0_67906358/article/details/128808210">GitHub注册</a></p><h5 id="然后我们就需要安装git"><a href="#然后我们就需要安装git" class="headerlink" title="然后我们就需要安装git"></a>然后我们就需要安装git</h5><p>这是下载的地址 <a href="https://git-scm.com/downloads">git</a>，你可以选择自己需要的版本下载。</p><p>我也丢一个教程在这里：<a href="https://blog.csdn.net/mukes/article/details/115693833">安装git</a>（绝对不是因为我懒）</p><p>安装完之后，任意页面右键出现git相关的选择项（主要是 git brash 就行了）</p><h5 id="完成以上步骤之后我们需要配置ssh"><a href="#完成以上步骤之后我们需要配置ssh" class="headerlink" title="完成以上步骤之后我们需要配置ssh"></a>完成以上步骤之后我们需要配置ssh</h5><p>老样子，丢个别人的教程 <a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">ssh配置</a> （就是懒行吧）</p><h5 id="之后就是安装node"><a href="#之后就是安装node" class="headerlink" title="之后就是安装node"></a>之后就是安装node</h5><p>这是官网：<a href="https://nodejs.org/en">ndoe.js</a></p><p><strong>注意：一定要选左边的！</strong></p><p>左边的是稳定版本，更加可靠，右边的是尝鲜版本，不是很稳定！</p><p>下载完之后无脑继续就行了</p><p>完成安装之后右键打开poweshell或者cmd（<strong>后面我就检测打开终端了</strong>）输入npm，看到版本号就说明安装成功了</p><p>由于node是默认安装在<strong>C盘</strong>下面的，如果你对自己的C盘比较不自信，可以给node搬个家（我比较建议搬个家）</p><p>你可以在其他盘想要的地方建一个文件夹（一定要英文名称，建议直接nodejs）</p><p>然后在里面建node_global和node_cache两个文件夹</p><p>打开终端，输入<code>npm config set prefix &quot;nodejs文件位置\node_global&quot;</code></p><p>再输入<code>node list -g</code>查看是否更改成功（显示empty是正常的）</p><p>同样的，我们再更改以下node_cache的位置<code>npm config set cache &quot;nodejs的位置\node_cache&quot;</code></p><p>输入<code>npm install express -g</code>检测一下（安装报错就用管理员身份重新运行一下</p><p>再输入<code>npm list -g</code>，这次不是empty说明成功了</p><p><strong>然后就是配置环境了！</strong></p><p>计算机右键属性-&gt;高级系统设置-&gt;path-&gt;编辑</p><p>把原来的C:\Users\用户名\AppData\Roaming\npm改为新的地址（node_global的位置）</p><p>再新建系统变量NODE_PATH,变量值是node_golbal里面node_modules 的位置</p><p>确定之后就配置完成了</p><h5 id="配置pnpm"><a href="#配置pnpm" class="headerlink" title="配置pnpm"></a>配置pnpm</h5><p>虽然node的npm已经足够大部分的使用了，但是他有一个致命的缺点：<strong>太慢了！</strong></p><p>这个时候我们就需要pnpm了！</p><p>pnpm适用范围极光，而且<strong>巨快！！</strong>，安装也相当简单</p><p>打开终端，输入<code>npm install -g pnpm</code>或者<code>npm install -g @pnpm/exe</code>就好了</p><p>安装完之后，我们还要配置一下镜像，一般来说用的是淘宝的镜像</p><p>终端输入<code>pnpm get registry</code>,<code>pnpm set registry https://registry.npm.taobao.org</code></p><p>你也可以修改安装包的位置（其实没啥必要我就不展开了）</p><p>然后你就可以愉快的使用pnpm了，就是这么简单（pnpm yyds！）</p><h3 id="2-hexo框架搭建"><a href="#2-hexo框架搭建" class="headerlink" title="2.hexo框架搭建"></a>2.hexo框架搭建</h3><p>完成前置点之后我们终于可以开始进入搭建环节了！</p><p>先让我们检查一下</p><p>终端输入<code>node -v</code>,<code>pnpm -v</code>和<code>git --version</code></p><p>有版本号就说明你已经准备好了</p><h5 id="首先链接GitHub"><a href="#首先链接GitHub" class="headerlink" title="首先链接GitHub"></a>首先链接GitHub</h5><p>设置用户名和邮箱<br><code>git config --global user.name &quot;GitHub 用户名&quot;</code><br><code>git config --global user.email &quot;GitHub 邮箱&quot;</code></p><p>创建SSH密钥：输入<code>ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;</code>然后一路回车</p><p>进入用户下的.ssh目录（要开显示隐藏文件），用记事本打开id_rsa.pub并复制里面内容</p><p>登录GitHub，进入setting，选择边栏的SSH and GPG keys，点击New SSH key</p><p>title随便取，黏贴复制的内容，点Add SSH key完成添加</p><p>然后就要<strong>验证链接了</strong></p><p>打开右键打开git brash，输入<code>ssh -T git@github.com</code>,出现“Are you sure……”,输入yes回车确定</p><p>显示“hi ***!……”就成功了</p><h5 id="然后创建GitHub-Page仓库"><a href="#然后创建GitHub-Page仓库" class="headerlink" title="然后创建GitHub Page仓库"></a>然后创建GitHub Page仓库</h5><p>GitHub主页右上角加号 -&gt; New repository</p><p>·仓库名输入 用户名.github.io（必须是这个格式）</p><p>·勾选“Initialize this repository with a README”</p><p>其他随便</p><p>最后点 Create repository </p><h5 id="开始正式搭建"><a href="#开始正式搭建" class="headerlink" title="开始正式搭建"></a>开始正式搭建</h5><p>先在自己喜欢的位置创建一个文件夹（名字要是英文，建议直接blog，我就称这个文件夹为blog了）</p><p>在blog里右键打开终端，输入<code>pnpm install -g hexo-cli</code>一键安装博客</p><p>这个时候就可直观体会pnpm和npm的区别了，npm半天才能安装完，而pnpm只需要短短几秒</p><p>下一步初始化并安装组件</p><p>输入：<code>hexo init</code>,<code>npm install</code>就完成了</p><p>是不是非常迅速？✌</p><p>现在让我们启动一下试试</p><p>输入<code>hexo g</code>完成本地部署</p><p>再输入<code>hexo s</code>启动服务器</p><p>他会跳出一个本地钉钉网址，按住CTRL点击就可以打开</p><p>如果正常的打开了一个网址，恭喜你！你已经成功搭建了一个个人博客！（虽然只是在本地）</p><p>下一步就是把你的博客部署到GitHub上了！</p><p>按CTRL加C退出hexo，让我们先安装点插件</p><p>首先，安装hexo-deployer-git:<code>pnpm install hexo-deployer-git --save</code></p><p>然后打开blog里面_config.yml文件的deployment部分，改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  repository: git@github.com:用户名/用户名.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure><p>完成之后输入<code>hexo d</code>将网站上传部署到GitHub上</p><p>在网页输入<code>https://用户名.github.io</code>就可以上你的个人博客了~</p><h5 id="在个人博客上上传自己的文章"><a href="#在个人博客上上传自己的文章" class="headerlink" title="在个人博客上上传自己的文章"></a>在个人博客上上传自己的文章</h5><p>创建文章的快捷输入方式是<code>hexo n &quot;文章名称&quot;</code></p><p>创建之后就可以在blog里面blog\source_posts位置找到新建的文章（结尾是.md）</p><p>用vscode打开这个文件就可以编辑了！</p><p>·注：md文件不是普通的txt或doc文件，他的编写也有些简单的语法，即MarkDown语法，具体怎么用可以看官方的文档<a href="https://markdown.com.cn/">MarkDown</a></p><p>编辑完成并保存之后在blog里打开终端，输入<code>hexo g</code>,<code>hexo d</code>，一段时间之后你的网站里就会出现你的新文章了</p><p>·注：文章更新需要一段时间，一时半会儿没别太急哈</p><h3 id="个人博客主页个性化"><a href="#个人博客主页个性化" class="headerlink" title="个人博客主页个性化"></a>个人博客主页个性化</h3><p>首先，你要找一个喜欢的个性化页面</p><p>这里我个人比较建议hexo自己给的个性化库<a href="https://hexo.io/themes/">hexo个性化库</a></p><p>去里面找一个自己喜欢的模板，打开其对应的GitHub库，跟着操作一步步走就行了👍</p><p>各个模板的操作可能不一样，我就不细说了，剩下就交给你自己慢慢探索了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0基础使用hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#0基础使用hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;0基础使用hexo搭建个人博客&quot;&gt;&lt;/a&gt;0基础使用hexo搭建个人博客&lt;/h1&gt;&lt;h2 id=&quot;先叠个甲：我是个菜鸡，如果</summary>
      
    
    
    
    <category term="article" scheme="http://passengerdong.github.io/categories/article/"/>
    
    
  </entry>
  
</feed>
